[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Strings",
    "section": "",
    "text": "About\n\n\n\n\n\n\n\n\n\nThis book aims to provide a panoramic perspective of the wide array of string manipulations that you can perform with R. If you are new to R, or lack experience working with character data, this book will help you get started with the basics of handling strings. Likewise, if you are already familiar with R, you will find material that shows you how to do more advanced string and text processing operations.\n\nAbout You\nI am assuming that you have both R or RStudio installed in your computer. If this is not the case, you can take a look at Breaking the Ice with R\nhttps://www.gastonsanchez.com/R-ice-breaker\n\n\nCitation\nYou can cite this work as:\nSanchez, G. (2024) Handling Strings with R.  https://www.gastonsanchez.com/R-for-strings\n\n\n\nMy Series of R Tutorials\nThis manuscript is part of a series of texts that I’ve written about Programming and Data Analysis in R:\n\nBreaking the Ice with R: Getting Started with R and RStudio  https://www.gastonsanchez.com/R-ice-breaker\nTidy Hurricanes: Analyzing Tropical Storms with Tidyverse Tools  https://www.gastonsanchez.com/R-tidy-hurricanes\nR Coding Basics: An Introduction to the Basics of Coding in R  https://www.gastonsanchez.com/R-coding-basics\nRolling Dice: Exploring Simulations in Games of Chance with R  https://www.gastonsanchez.com/R-rolling-dice\nR for Strings: Handling Strings with R  https://www.gastonsanchez.com/R-for-strings\nWeb Technologies in R: A Short Introduction to Web Technologies in R  <https://www.gastonsanchez.com/R-web-technologies” target=“_blank”>https://www.gastonsanchez.com/R-web-technologies\n\n\n\n\nDonation\nAs a Data Science and Statistics educator, I love to share the work I do. Each month I spend dozens of hours curating learning materials like this resource. If you find any value and usefulness in it, please consider making a one-time donation—via paypal—in any amount (e.g. the amount you would spend inviting me a cup of coffee or any other drink). Your support really matters.\n\n\n\nLicense\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "01-introduction.html",
    "href": "01-introduction.html",
    "title": "1  Introductory Appetizer",
    "section": "",
    "text": "To give you an idea of some of the things we can do in R with string processing, let’s play a bit with a simple example."
  },
  {
    "objectID": "01-introduction.html#a-toy-example",
    "href": "01-introduction.html#a-toy-example",
    "title": "1  Introductory Appetizer",
    "section": "1.1 A Toy Example",
    "text": "1.1 A Toy Example\nFor this crash informal introduction, we’ll use the data frame USArrests that already comes with R. Use the function head() to get a peek of the data:\n\n# take a peek of USArrests\nhead(USArrests)\n\n           Murder Assault UrbanPop Rape\nAlabama      13.2     236       58 21.2\nAlaska       10.0     263       48 44.5\nArizona       8.1     294       80 31.0\nArkansas      8.8     190       50 19.5\nCalifornia    9.0     276       91 40.6\nColorado      7.9     204       78 38.7\n\n\nThe labels on the rows such as Alabama or Alaska are displayed strings. Likewise, the labels of the columns—Murder, Assault, UrbanPop and Rape—are also strings.\n\n1.1.1 Abbreviating strings\nSuppose we want to abbreviate the names of the States. Furthermore, suppose we want to abbreviate the names using the first four characters of each name. One way to do that is by using the function substr() which substrings a character vector. We just need to indicate the start=1 and stop=4 positions:\n\n# names of states\nstates <- rownames(USArrests)\n\n# substr\nsubstr(x = states, start = 1, stop = 4)\n\n [1] \"Alab\" \"Alas\" \"Ariz\" \"Arka\" \"Cali\" \"Colo\" \"Conn\" \"Dela\" \"Flor\" \"Geor\"\n[11] \"Hawa\" \"Idah\" \"Illi\" \"Indi\" \"Iowa\" \"Kans\" \"Kent\" \"Loui\" \"Main\" \"Mary\"\n[21] \"Mass\" \"Mich\" \"Minn\" \"Miss\" \"Miss\" \"Mont\" \"Nebr\" \"Neva\" \"New \" \"New \"\n[31] \"New \" \"New \" \"Nort\" \"Nort\" \"Ohio\" \"Okla\" \"Oreg\" \"Penn\" \"Rhod\" \"Sout\"\n[41] \"Sout\" \"Tenn\" \"Texa\" \"Utah\" \"Verm\" \"Virg\" \"Wash\" \"West\" \"Wisc\" \"Wyom\"\n\n\nThis may not be the best solution. Note that there are four states with the same abbreviation \"New \" (New Hampshire, New Jersey, New Mexico, New York). Likewise, North Carolina and North Dakota share the same name \"Nort\". In turn, South Carolina and South Dakota got the same abbreviation \"Sout\".\nA better way to abbreviate the names of the states can be performed by using the function abbreviate() like so:\n\n# abbreviate state names\nstates2 <- abbreviate(states)\n\n# remove vector names (for convenience)\nnames(states2) <- NULL\nstates2\n\n [1] \"Albm\" \"Alsk\" \"Arzn\" \"Arkn\" \"Clfr\" \"Clrd\" \"Cnnc\" \"Dlwr\" \"Flrd\" \"Gerg\"\n[11] \"Hawa\" \"Idah\" \"Illn\" \"Indn\" \"Iowa\" \"Knss\" \"Kntc\" \"Losn\" \"Main\" \"Mryl\"\n[21] \"Mssc\" \"Mchg\" \"Mnns\" \"Msss\" \"Mssr\" \"Mntn\" \"Nbrs\" \"Nevd\" \"NwHm\" \"NwJr\"\n[31] \"NwMx\" \"NwYr\" \"NrtC\" \"NrtD\" \"Ohio\" \"Oklh\" \"Orgn\" \"Pnns\" \"RhdI\" \"SthC\"\n[41] \"SthD\" \"Tnns\" \"Texs\" \"Utah\" \"Vrmn\" \"Vrgn\" \"Wshn\" \"WstV\" \"Wscn\" \"Wymn\"\n\n\nIf we decide to try an abbreviation with five letters we just simply change the argument minlength = 5\n\n# abbreviate state names with 5 letters\nabbreviate(states, minlength = 5)\n\n       Alabama         Alaska        Arizona       Arkansas     California \n       \"Alabm\"        \"Alask\"        \"Arizn\"        \"Arkns\"        \"Clfrn\" \n      Colorado    Connecticut       Delaware        Florida        Georgia \n       \"Colrd\"        \"Cnnct\"        \"Delwr\"        \"Flord\"        \"Georg\" \n        Hawaii          Idaho       Illinois        Indiana           Iowa \n       \"Hawai\"        \"Idaho\"        \"Illns\"        \"Indin\"         \"Iowa\" \n        Kansas       Kentucky      Louisiana          Maine       Maryland \n       \"Kanss\"        \"Kntck\"        \"Lousn\"        \"Maine\"        \"Mryln\" \n Massachusetts       Michigan      Minnesota    Mississippi       Missouri \n       \"Mssch\"        \"Mchgn\"        \"Mnnst\"        \"Mssss\"        \"Missr\" \n       Montana       Nebraska         Nevada  New Hampshire     New Jersey \n       \"Montn\"        \"Nbrsk\"        \"Nevad\"        \"NwHmp\"        \"NwJrs\" \n    New Mexico       New York North Carolina   North Dakota           Ohio \n       \"NwMxc\"        \"NwYrk\"        \"NrthC\"        \"NrthD\"         \"Ohio\" \n      Oklahoma         Oregon   Pennsylvania   Rhode Island South Carolina \n       \"Oklhm\"        \"Oregn\"        \"Pnnsy\"        \"RhdIs\"        \"SthCr\" \n  South Dakota      Tennessee          Texas           Utah        Vermont \n       \"SthDk\"        \"Tnnss\"        \"Texas\"         \"Utah\"        \"Vrmnt\" \n      Virginia     Washington  West Virginia      Wisconsin        Wyoming \n       \"Virgn\"        \"Wshng\"        \"WstVr\"        \"Wscns\"        \"Wymng\" \n\n\n\n\n1.1.2 Getting the longest name\nNow let’s imagine that we need to find the longest name. This implies that we need to count the number of letters in each name. The function nchar() comes handy for that purpose. Here’s how we could do it:\n\n# size (in characters) of each name\nstate_chars = nchar(states)\nstate_chars\n\n [1]  7  6  7  8 10  8 11  8  7  7  6  5  8  7  4  6  8  9  5  8 13  8  9 11  8\n[26]  7  8  6 13 10 10  8 14 12  4  8  6 12 12 14 12  9  5  4  7  8 10 13  9  7\n\n# longest name\nstates[which(state_chars == max(state_chars))]\n\n[1] \"North Carolina\" \"South Carolina\"\n\n\n\n\n1.1.3 Selecting States\nTo make things more interesting, let’s assume that we wish to select those states containing the letter \"k\". How can we do that? Very simple, we just need to use the function grep() for working with regular expressions. Simply indicate the pattern = \"k\" as follows:\n\n# get states names with 'k'\ngrep(pattern = \"k\", x = states, value = TRUE)\n\n[1] \"Alaska\"       \"Arkansas\"     \"Kentucky\"     \"Nebraska\"     \"New York\"    \n[6] \"North Dakota\" \"Oklahoma\"     \"South Dakota\"\n\n\nInstead of grabbing those names containing \"k\", say we wish to select those states containing the letter \"w\". Again, this can be done with grep():\n\n# get states names with 'w'\ngrep(pattern = \"w\", x = states, value = TRUE)\n\n[1] \"Delaware\"      \"Hawaii\"        \"Iowa\"          \"New Hampshire\"\n[5] \"New Jersey\"    \"New Mexico\"    \"New York\"     \n\n\nNotice that we only selected those states with lowercase \"w\". But what about those states with uppercase \"W\"? There are several options to find a solution for this question. One option is to specify the searched pattern as a character class \"[wW]\":\n\n# get states names with 'w' or 'W'\ngrep(pattern = \"[wW]\", x = states, value = TRUE)\n\n [1] \"Delaware\"      \"Hawaii\"        \"Iowa\"          \"New Hampshire\"\n [5] \"New Jersey\"    \"New Mexico\"    \"New York\"      \"Washington\"   \n [9] \"West Virginia\" \"Wisconsin\"     \"Wyoming\"      \n\n\nAnother solution is to first convert the state names to lower case, and then look for the character \"w\", like so:\n\n# get states names with 'w'\ngrep(pattern = \"w\", x = tolower(states), value = TRUE)\n\n [1] \"delaware\"      \"hawaii\"        \"iowa\"          \"new hampshire\"\n [5] \"new jersey\"    \"new mexico\"    \"new york\"      \"washington\"   \n [9] \"west virginia\" \"wisconsin\"     \"wyoming\"      \n\n\nAlternatively, instead of converting the state names to lower case we could do the opposite (convert to upper case), and then look for the character \"W\", like so:\n\n# get states names with 'W'\ngrep(pattern = \"W\", x = toupper(states), value = TRUE)\n\n [1] \"DELAWARE\"      \"HAWAII\"        \"IOWA\"          \"NEW HAMPSHIRE\"\n [5] \"NEW JERSEY\"    \"NEW MEXICO\"    \"NEW YORK\"      \"WASHINGTON\"   \n [9] \"WEST VIRGINIA\" \"WISCONSIN\"     \"WYOMING\"      \n\n\nA third solution involves specifying the argument ignore.case=TRUE inside grep():\n\n# get states names with 'w'\ngrep(pattern = \"w\", x = states, value = TRUE, ignore.case = TRUE)\n\n [1] \"Delaware\"      \"Hawaii\"        \"Iowa\"          \"New Hampshire\"\n [5] \"New Jersey\"    \"New Mexico\"    \"New York\"      \"Washington\"   \n [9] \"West Virginia\" \"Wisconsin\"     \"Wyoming\"      \n\n\n\n\n1.1.4 Some computations\nBesides manipulating strings and performing pattern matching operations, we can also do some computations. For instance, we could ask for the distribution of the State names’ length. To find the answer we can use nchar(). Furthermore, we can plot a histogram of such distribution:\n\nsummary(nchar(states))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   4.00    7.00    8.00    8.44   10.00   14.00 \n\n# histogram\nhist(nchar(states), las = 1, col = \"gray80\", main = \"Histogram\", \n     xlab = \"number of characters in US State names\")\n\n\n\n\n\n\n\n\nLet’s ask a more interesting question. What is the distribution of the vowels in the names of the States? For instance, let’s start with the number of a’s in each name. There’s a very useful function for this purpose: regexpr(). We can use regexpr() to get the number of times that a searched pattern is found in a character vector. When there is no match, we get a value -1.\n\n# position of a's\npositions_a <- gregexpr(pattern=\"a\", text=states, ignore.case = TRUE)\n\n# how many a's?\nnum_a <- sapply(positions_a, function(x) ifelse(x[1]>0, length(x), 0))\nnum_a\n\n [1] 4 3 2 3 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2\n[39] 1 2 2 0 1 1 0 1 1 1 0 0\n\n\nIf you inspect positions_a you’ll see that it contains some negative numbers -1. This means there are no letters a in that name. To get the number of occurrences of a’s we are taking a shortcut with sapply().\nThe same operation can be performed by using the function str_count() from the package \"stringr\".\n\n# load stringr (remember to install it first)\nlibrary(stringr)\n\n# total number of a's\nstr_count(states, \"a\")\n\n [1] 3 2 1 2 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2\n[39] 1 2 2 0 1 1 0 1 1 1 0 0\n\n\nNotice that we are only getting the number of a’s in lower case. Since str_count() does not contain the argument ignore.case, we need to transform all letters to lower case, and then count the number of a’s like this:\n\n# total number of a's\nstr_count(tolower(states), \"a\")\n\n [1] 4 3 2 3 2 1 0 2 1 1 2 1 0 2 1 2 0 2 1 2 2 1 1 0 0 2 2 2 1 0 0 0 2 2 0 2 0 2\n[39] 1 2 2 0 1 1 0 1 1 1 0 0\n\n\nOnce we know how to do it for one vowel, we can do the same for all the vowels:\n\n# calculate number of vowels in each name\nvowels <- c(\"a\", \"e\", \"i\", \"o\", \"u\")\nnum_vowels <- vector(mode = \"integer\", length = 5)\n\nfor (j in seq_along(vowels)) {\n  num_aux <- str_count(tolower(states), vowels[j])\n  num_vowels[j] <- sum(num_aux)\n}\n\n# sort them in decreasing order\nnames(num_vowels) <- vowels\nsort(num_vowels, decreasing = TRUE)\n\n a  i  o  e  u \n61 44 36 28  8 \n\n# barplot\nbarplot(num_vowels, main = \"Number of vowels in USA States names\", \n        border = NA, xlim = c(0, 80), las = 1, horiz = TRUE)"
  },
  {
    "objectID": "02-characters.html",
    "href": "02-characters.html",
    "title": "2  Character Strings in R",
    "section": "",
    "text": "This chapter introduces you to the basic concepts for creating character vectors and character strings in R. You will also learn how R treats objects containing characters."
  },
  {
    "objectID": "02-characters.html#characters-in-r",
    "href": "02-characters.html#characters-in-r",
    "title": "2  Character Strings in R",
    "section": "2.1 Characters in R",
    "text": "2.1 Characters in R\nIn R, a piece of text is represented as a sequence of characters (letters, numbers, and symbols). The data type R provides for storing sequences of characters is character. Formally, the mode of an object that holds character strings in R is \"character\".\nYou express character strings by surrounding text within double quotes:\n\n\"a character string using double quotes\"\n\nor you can also surround text within single quotes:\n\n'a character string using single quotes'\n\nThe important thing is that you must match the type of quotes that your are using. A starting double quote must have an ending double quote. Likewise, a string with an opening single quote must be closed with a single quote.\nTyping characters in R like in above examples is not very useful. Typically, you are going to create objects or variables containing some strings. For example, you can create a variable string that stores some string:\n\nstring <- 'do more with less'\nstring\n\n[1] \"do more with less\"\n\n\nNotice that when you print a character object, R displays it using double quotes (regardless of whether the string was created using single or double quotes). This allows you to quickly identify when an object contains character values.\nWhen writing strings, you can insert single quotes in a string with double quotes, and vice versa:\n\n# single quotes within double quotes\nex1 <- \"The 'R' project for statistical computing\"\n\n\n# double quotes within single quotes\nex2 <- 'The \"R\" project for statistical computing'\n\nHowever, you cannot directly insert single quotes in a string with single quotes, neither you can insert double quotes in a string with double quotes (Don’t do this!):\n\nex3 <- \"This \"is\" totally unacceptable\"\n\n\nex4 <- 'This 'is' absolutely wrong'\n\nIn both cases R will give you an error due to the unexpected presence of either a double quote within double quotes, or a single quote within single quotes.\nIf you really want to include a double quote as part of the string, you need to escape the double quote using a backslash \\ before it:\n\n\"The \\\"R\\\" project for statistical computing\"\n\nWe will talk more about escaping characters in the following chapters."
  },
  {
    "objectID": "02-characters.html#getting-started-with-strings",
    "href": "02-characters.html#getting-started-with-strings",
    "title": "2  Character Strings in R",
    "section": "2.2 Getting Started with Strings",
    "text": "2.2 Getting Started with Strings\nPerhaps the most common use of character strings in R has to do with:\n\nnames of files and directories\nnames of elements in data objects\ntext elements displayed in plots and graphs\n\nWhen you read a file, for instance a data table stored in a csv file, you typically use the read.table() function and friends—e.g. read.csv(), read.delim(). Assuming that the file dataset.csv is in your working directory:\n\ndat <- read.csv(file = 'dataset.csv')\n\nThe main parameter for the function read.csv() is file which requires a character string with the pathname of the file.\nAnother example of a basic use of characters is when you assign names to the elements of some data structure in R. For instance, if you want to name the elements of a (numeric) vector, you can use the function names() as follows:\n\nnum_vec <- 1:5\nnames(num_vec) <- c('uno', 'dos', 'tres', 'cuatro', 'cinco')\nnum_vec\n\nLikewise, many of the parameters in the plotting functions require some sort of input string. Below is a hypothetical example of a scatterplot that includes several graphical elements like the main title (main), subtitle (sub), labels for both x-axis and y-axis (xlab, ylab), the name of the color (col), and the symbol for the point character (pch).\n\nplot(x, y, \n     main = 'Main Title', \n     sub = 'Subtitle',\n     xlab = 'x-axis label', \n     ylab = 'y-axis label',\n     col = 'red', \n     pch = 'x')"
  },
  {
    "objectID": "02-characters.html#creating-character-strings",
    "href": "02-characters.html#creating-character-strings",
    "title": "2  Character Strings in R",
    "section": "2.3 Creating Character Strings",
    "text": "2.3 Creating Character Strings\nBesides the single quotes '' or double quotes \"\", R provides the function character() to create character vectors. More specifically, character() is the function that creates vector objects of type \"character\".\nWhen using character() you just have to specify the length of the vector. The output will be a character vector filled of empty strings:\n\n# character vector with 5 empty strings\nchar_vector <- character(5)\nchar_vector\n\n[1] \"\" \"\" \"\" \"\" \"\"\n\n\nWhen would you use character()? A typical usage case is when you want to initialize an empty character vector of a given length. The idea is to create an object that you will modify later with some computation.\nAs with any other vector, once an empty character vector has been created, you can add new components to it by simply giving it an index value outside its previous range:\n\n# another example\nexample <- character(0)\nexample\n\ncharacter(0)\n\n# check its length\nlength(example)\n\n[1] 0\n\n# add first element\nexample[1] <- \"first\"\nexample\n\n[1] \"first\"\n\n# check its length again\nlength(example)\n\n[1] 1\n\n\nYou can add more elements without the need to follow a consecutive index range:\n\nexample[4] <- \"fourth\"\nexample\n\n[1] \"first\"  NA       NA       \"fourth\"\n\nlength(example)\n\n[1] 4\n\n\nNotice that the vector example went from containing one-element to contain four-elements without specifying the second and third elements. R fills this gap with missing values NA.\n\n2.3.1 Empty string\nThe most basic type of string is the empty string produced by consecutive quotation marks: \"\". Technically, \"\" is a string with no characters in it, hence the name “empty string”:\n\n# empty string\nempty_str <- \"\"\nempty_str\n\n[1] \"\"\n\n# class\nclass(empty_str)\n\n[1] \"character\"\n\n\n\n\n2.3.2 Empty character vector\nAnother basic string structure is the empty character vector produced by the function character() and its argument length=0:\n\n# empty character vector\nempty_chr <- character(0)\nempty_chr\n\ncharacter(0)\n\n# class\nclass(empty_chr)\n\n[1] \"character\"\n\n\nIt is important not to confuse the empty character vector character(0) with the empty string \"\"; one of the main differences between them is that they have different lengths:\n\n# length of empty string\nlength(empty_str)\n\n[1] 1\n\n# length of empty character vector\nlength(empty_chr)\n\n[1] 0\n\n\nNotice that the empty string empty_str has length 1, while the empty character vector empty_chr has length 0.\nAlso, character(0) occurs when you have a character vector with one or more elements, and you attempt to subset the position 0:\n\nstring <- c('sun', 'sky', 'clouds')\nstring\n\n[1] \"sun\"    \"sky\"    \"clouds\"\n\n\nIf you try to retrieve the element in position 0 you get:\n\nstring[0]\n\ncharacter(0)\n\n\n\n\n2.3.3 Function c()\nThere is also the generic function c() (concatenate or combine) that you can use to create character vectors. Simply pass any number of character elements separated by commas:\n\nstring <- c('sun', 'sky', 'clouds')\nstring\n\n[1] \"sun\"    \"sky\"    \"clouds\"\n\n\nAgain, notice that you can use single or double quotes to define the character elements inside c()\n\nplanets <- c(\"mercury\", 'venus', \"mars\")\nplanets\n\n[1] \"mercury\" \"venus\"   \"mars\"   \n\n\n\n\n2.3.4 is.character() and as.character()\nRelated to character() R provides two related functions: as.character() and is.character(). These two functions are methods for coercing objects to type \"character\", and testing whether an R object is of type \"character\". For instance, let’s define two objects a and b as follows:\n\n# define two objects 'a' and 'b'\na <- \"test me\"\nb <- 8 + 9\n\nTo test if a and b are of type \"character\" use the function is.character():\n\n# are 'a' and 'b' characters?\nis.character(a)\n\n[1] TRUE\n\nis.character(b)\n\n[1] FALSE\n\n\nLikewise, you can also use the function class() to get the class of an object:\n\n# classes of 'a' and 'b'\nclass(a)\n\n[1] \"character\"\n\nclass(b)\n\n[1] \"numeric\"\n\n\nThe function as.character() is a coercing method. For better or worse, R allows you to convert (i.e. coerce) non-character objects into character strings with the function as.character():\n\n# converting 'b' as character\nb <- as.character(b)\nb\n\n[1] \"17\""
  },
  {
    "objectID": "02-characters.html#strings-and-r-objects",
    "href": "02-characters.html#strings-and-r-objects",
    "title": "2  Character Strings in R",
    "section": "2.4 Strings and R Objects",
    "text": "2.4 Strings and R Objects\nBefore continuing our discussion on functions for manipulating strings, we need to talk about some important technicalities. R has five main types of objects to store data: vector, factor, matrix (and array), data.frame, and list. We can use each of those objects to store character strings. However, these objects will behave differently depending on whether we store character data with other types of data. Let’s see how R treats objects with different types of data (e.g. character, numeric, logical).\n\n2.4.1 Behavior of R objects with character strings\nVectors. The most basic type of data container are vectors. You can think of vectors as the building blocks for other more complex data structures. R has six types of vectors, technically referred to as atomic types or atomic vectors: logical, integer, double, character, complex, and raw.\n\n\n\nType\nDescription\n\n\n\n\nlogical\na vector containing logical values\n\n\ninteger\na vector containing integer values\n\n\ndouble\na vector containing real values\n\n\ncharacter\na vector containing character values\n\n\ncomplex\na vector containing complex values\n\n\nraw\na vector containing bytes\n\n\n\nVectors are atomic structures because their values must be all of the same type. This means that any given vector must be unambiguously either logical, numeric, complex, character or raw.\nSo what happens when you mix different types of data in a vector?\n\n# vector with numbers and characters\nc(1:5, pi, \"text\")\n\n[1] \"1\"                \"2\"                \"3\"                \"4\"               \n[5] \"5\"                \"3.14159265358979\" \"text\"            \n\n\nAs you can tell, the resulting vector from combining integers 1:5, the number pi, and some \"text\" is a vector with all its elements treated as character strings. In other words, when you combine mixed data in vectors, strings will dominate. This means that the mode of the vector will be \"character\", even if you mix logical values:\n\n# vector with numbers, logicals, and characters\nc(1:5, TRUE, pi, \"text\", FALSE)\n\n[1] \"1\"                \"2\"                \"3\"                \"4\"               \n[5] \"5\"                \"TRUE\"             \"3.14159265358979\" \"text\"            \n[9] \"FALSE\"           \n\n\nIn fact, R follows two basic rules of data types coercion. The most strict rule is: if a character string is present in a vector, everything else in the vector will be converted to character strings. The other coercing rule is: if a vector only has logicals and numbers, then logicals will be converted to numbers; TRUE values become 1, and FALSE values become 0.\nKeeping these rules in mind will save you from many headaches and frustrating moments. Moreover, you can use them in your favor to manipulate data in very useful ways.\nMatrices. The same behavior of vectors happens when you mix characters and numbers in matrices. Again, everything will be treated as characters:\n\n# matrix with numbers and characters\nrbind(1:5, letters[1:5])\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"1\"  \"2\"  \"3\"  \"4\"  \"5\" \n[2,] \"a\"  \"b\"  \"c\"  \"d\"  \"e\" \n\n\nData frames. With data frames, things are a bit different. By default, character strings inside a data frame will be converted to factors:\n\n# data frame with numbers and characters\ndf1 = data.frame(numbers=1:5, letters=letters[1:5])\ndf1\n\n  numbers letters\n1       1       a\n2       2       b\n3       3       c\n4       4       d\n5       5       e\n\n# examine the data frame structure\nstr(df1)\n\n'data.frame':   5 obs. of  2 variables:\n $ numbers: int  1 2 3 4 5\n $ letters: chr  \"a\" \"b\" \"c\" \"d\" ...\n\n\nTo turn-off the data.frame()’s default behavior of converting strings into factors, use the argument stringsAsFactors = FALSE:\n\n# data frame with numbers and characters\ndf2 <- data.frame(\n  numbers = 1:5, \n  letters = letters[1:5], \n  stringsAsFactors = FALSE)\n\ndf2\n\n  numbers letters\n1       1       a\n2       2       b\n3       3       c\n4       4       d\n5       5       e\n\n# examine the data frame structure\nstr(df2)\n\n'data.frame':   5 obs. of  2 variables:\n $ numbers: int  1 2 3 4 5\n $ letters: chr  \"a\" \"b\" \"c\" \"d\" ...\n\n\nEven though df1 and df2 are identically displayed, their structure is different. While df1$letters is stored as a \"factor\", df2$letters is stored as a \"character\".\nLists. With lists, you can combine any type of data objects. The type of data in each element of the list will maintain its corresponding mode:\n\n# list with elements of different mode\nlist(1:5, letters[1:5], rnorm(5))\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"a\" \"b\" \"c\" \"d\" \"e\"\n\n[[3]]\n[1] -0.4034850  0.6651950 -0.1344302  1.2346755  0.4881856"
  },
  {
    "objectID": "02-characters.html#the-workhorse-function-paste",
    "href": "02-characters.html#the-workhorse-function-paste",
    "title": "2  Character Strings in R",
    "section": "2.5 The Workhorse Function paste()",
    "text": "2.5 The Workhorse Function paste()\nThe function paste() is perhaps one of the most important functions that you can use to create and build strings. paste() takes one or more R objects, converts them to \"character\", and then it concatenates (pastes) them to form one or several character strings. Its usage has the following form:\npaste(..., sep = \" \", collapse = NULL)\nThe argument ... means that it takes any number of objects. The argument sep is a character string that is used as a separator. The argument collapse is an optional string to indicate if you want all the terms to be collapsed into a single string. Here is a simple example with paste():\n\n# paste\nPI <- paste(\"The life of\", pi)\n\nPI\n\n[1] \"The life of 3.14159265358979\"\n\n\nAs you can see, the default separator is a blank space (sep = \" \"). But you can select another character, for example sep = \"-\":\n\n# paste\nIloveR <- paste(\"I\", \"love\", \"R\", sep = \"-\")\n\nIloveR\n\n[1] \"I-love-R\"\n\n\nIf you give paste() objects of different length, then it will apply a recycling rule. For example, if you paste a single character \"X\" with the sequence 1:5, and separator sep = \".\", this is what you get:\n\n# paste with objects of different lengths\npaste(\"X\", 1:5, sep = \".\")\n\n[1] \"X.1\" \"X.2\" \"X.3\" \"X.4\" \"X.5\"\n\n\nTo see the effect of the collapse argument, let’s compare the difference with collapsing and without it:\n\n# paste with collapsing\npaste(1:3, c(\"!\",\"?\",\"+\"), sep = '', collapse = \"\")\n\n[1] \"1!2?3+\"\n\n# paste without collapsing\npaste(1:3, c(\"!\",\"?\",\"+\"), sep = '')\n\n[1] \"1!\" \"2?\" \"3+\"\n\n\nOne of the potential problems with paste() is that it coerces missing values NA into the character \"NA\":\n\n# with missing values NA\nevalue <- paste(\"the value of 'e' is\", exp(1), NA)\n\nevalue\n\n[1] \"the value of 'e' is 2.71828182845905 NA\"\n\n\nIn addition to paste(), there’s also the function paste0() which is the equivalent of\npaste(..., sep = \"\", collapse)\n\n# collapsing with paste0\npaste0(\"let's\", \"collapse\", \"all\", \"these\", \"words\")\n\n[1] \"let'scollapseallthesewords\""
  },
  {
    "objectID": "02-characters.html#getting-text-into-r",
    "href": "02-characters.html#getting-text-into-r",
    "title": "2  Character Strings in R",
    "section": "2.6 Getting Text into R",
    "text": "2.6 Getting Text into R\nWe’ve seen how to express character strings using single quotes '' or double quotes \"\". But we also need to discuss how to get text into R, that is, how to import and read files that contain character strings. So, how do we get text into R? Well, it basically depends on the type-format of the files we want to read.\nWe will describe two general situations. One in which the content of the file can be represented in tabular format (i.e. rows and columns). The other one when the content does not have a tabular structure. In this second case, we have characters that are in an unstructured form (i.e. just lines of strings) or at least in a non-tabular format such as html, xml, or other markup language format.\nAnother function is scan() which allows us to read data in several formats. Usually we use scan() to parse R scripts, but we can also use to import text (characters)\n\n2.6.1 Reading tables\nIf the data we want to import is in some tabular format (i.e. cells and columns) we can use the set of functions to read tables like read.table() and its sister functions, e.g. read.csv(), read.delim(), read.fwf(). These functions read a file in table format and create a data frame from it, with rows corresponding to cases, and columns corresponding to fields in the file.\n\n\n\nFunction\nDescription\n\n\n\n\nread.table()\nmain function to read file in table format\n\n\nread.csv()\nreads csv files separated by a comma \",\"\n\n\nread.csv2()\nreads csv files separated by a semicolon \";\"\n\n\nread.delim()\nreads files separated by tabs \"\\t\"\n\n\nread.delim2()\nsimilar to read.delim()\n\n\nread.fwf()\nread fixed width format files\n\n\n\nA word of caution about the built-in functions to read data tables: by default they all convert characters into R factors. This means that if there is a column with characters, R will treat this data as qualitative variable. To turn off this behavior, we need to specify the argument stringsAsFactors = FALSE. In this way, all the characters in the imported file will be kept as characters once we read them in R.\nLet’s see a simple example reading a file from the Australian radio broadcaster ABC (http://www.abc.net.au/radio/). In particular, we’ll read a csv file that contains data from ABC’s radio stations. Such file is located at:\nhttp://www.abc.net.au/local/data/public/stations/abc-local-radio.csv\nTo import the file abc-local-radio.csv, we can use either read.table() or read.csv() (just choose the right parameters). Here’s the code to read the file with read.table():\n\n\n\n\n# assembling url\nabc <- \"http://www.abc.net.au/\"\nradios <- \"local/data/public/stations/abc-local-radio.csv\"\nabc_radiosl <- paste0(abc, radios)\n\n# read data from URL\nradio <- read.table(\n  file = abc_radios, \n  header = TRUE, \n  sep = ',', \n  stringsAsFactors = FALSE)\n\nIn this case, the location of the file is defined in the object abc which is the first argument passed to read.table(). Then we choose other arguments such as header = TRUE, sep = \",\", and stringsAsFactors = FALSE. The argument header = TRUE indicates that the first row of the file contains the names of the columns. The separator (a comma) is specifcied by sep = \",\". And finally, to keep the character strings in the file as \"character\" in the data frame, we use stringsAsFactors = FALSE.\nIf everything went fine during the file reading operation, the next thing to do is to chek the size of the created data frame using dim():\n\n# size of table in 'radio'\ndim(radio)\n\n[1] 53 18\n\n\nNotice that the data frame radio is a table with 53 rows and 18 columns. If we examine ths structure with str() we will get information of each column. The argument vec.len = 1 indicates that we just want the first element of each variable to be displayed:\n\n# structure of columns\nstr(radio, vec.len = 1)\n\n'data.frame':   53 obs. of  18 variables:\n $ State           : chr  \"QLD\" ...\n $ Website.URL     : chr  \"http://www.abc.net.au/brisbane/\" ...\n $ Station         : chr  \"ABC Radio Brisbane\" ...\n $ Town            : chr  \" Brisbane \" ...\n $ Latitude        : num  -27.5 ...\n $ Longitude       : num  153 ...\n $ Talkback.number : chr  \"1300 222 612\" ...\n $ Enquiries.number: chr  \"07 3377 5222\" ...\n $ Fax.number      : chr  \"07 3377 5612\" ...\n $ Sms.number      : chr  \"0467 922 612\" ...\n $ Street.number   : chr  \"114 Grey Street\" ...\n $ Street.suburb   : chr  \"South Brisbane\" ...\n $ Street.postcode : int  4101 4700 ...\n $ PO.box          : chr  \"GPO Box 9994\" ...\n $ PO.suburb       : chr  \"Brisbane\" ...\n $ PO.postcode     : int  4001 4700 ...\n $ Twitter         : chr  \" abcbrisbane\" ...\n $ Facebook        : chr  \" https://www.facebook.com/abcinbrisbane\" ...\n\n\nAs you can tell, most of the 18 variables are in \"character\" mode. Only $Latitude, $Longitude, $Street.postcode and $PO.postcode have a different mode.\n\n\n2.6.2 Reading raw text\nIf what we want is to import text as is (i.e. we want to read raw text) then we need to use the function readLines(). This function is the one we should use if we don’t want R to assume that the data is in any particular form.\nThe way we work with readLines() is by passing it the name of a file or the name of a URL that we want to read. The output is a character vector with one element for each line of the file or url. The produced vector will contain as many elements as lines in the read file.\nLet’s see how to read a text file. For this example we will use a text file from the site TEXTFILES.COM (by Jason Scott) http://www.textfiles.com/music/ . This site contains a section of music related text files. For demonstration purposes let’s consider the “Top 105.3 songs of 1991” according to the “Modern Rock” radio station KITS San Francisco. The corresponding txt file is located at:\nhttp://www.textfiles.com/music/ktop100.txt.\n\n\n\n\n# read 'ktop100.txt' file\ntop105 <- readLines(\"http://www.textfiles.com/music/ktop100.txt\")\n\nreadLines() creates a character vector in which each element represents the lines of the URL we are trying to read. To know how many elements (i.e how many lines) are in top105 we can use the function length(). To inspect the first elements (i.e. first lines of the text file) use head()\n\n# how many lines\nlength(top105)\n\n[1] 123\n\n# inspecting first elements\nhead(top105)\n\n[1] \"From: ed@wente.llnl.gov (Ed Suranyi)\"\n[2] \"Date: 12 Jan 92 21:23:55 GMT\"        \n[3] \"Newsgroups: rec.music.misc\"          \n[4] \"Subject: KITS' year end countdown\"   \n[5] \"\"                                    \n[6] \"\"                                    \n\n\nLooking at the output provided by head() the first four lines contain some information about the subject of the email (KITS’ year end countdown). The fifth and sixth lines are empty lines. If we inspect the next few lines, we’ll see that the list of songs in the top100 starts at line number 11.\n\n# top 5 songs\ntop105[11:15]\n\n[1] \"1. NIRVANA                      SMELLS LIKE TEEN SPIRIT\"\n[2] \"2. EMF                          UNBELIEVABLE\"           \n[3] \"3. R.E.M.                       LOSING MY RELIGION\"     \n[4] \"4. SIOUXSIE & THE BANSHEES      KISS THEM FOR ME\"       \n[5] \"5. B.A.D. II                    RUSH\"                   \n\n\nEach line has the ranking number, followed by a dot, followed by a blank space, then the name of the artist/group, followed by a bunch of white spaces, and then the title of the song. As you can see, the number one hit of 1991 was “Smells like teen spirit” by Nirvana.\nWhat about the last songs in KITS’ ranking? In order to get the answer we can use the tail() function to inspect the last n = 10 elements of the file:\n\n# inspecting last 10 elements\ntail(top105, n = 10)\n\n [1] \"101. SMASHING PUMPKINS          SIVA\"                       \n [2] \"102. ELVIS COSTELLO             OTHER SIDE OF ...\"          \n [3] \"103. SEERS                      PSYCHE OUT\"                 \n [4] \"104. THRILL KILL CULT           SEX ON WHEELZ\"              \n [5] \"105. MATTHEW SWEET              I'VE BEEN WAITING\"          \n [6] \"105.3  LATOUR                   PEOPLE ARE STILL HAVING SEX\"\n [7] \"\"                                                           \n [8] \"Ed\"                                                         \n [9] \"ed@wente.llnl.gov\"                                          \n[10] \"\"                                                           \n\n\nNote that the last four lines don’t contain information about the songs. Moreover, the number of songs does not stop at 105. In fact the ranking goes till 106 songs (last number being 105.3)\nWe’ll stop here the discussion of this chapter. However, it is importat to keep in mind that text files come in a great variety of forms, shapes, sizes, and flavors. For more information on how to import files in R, the authoritative document is the guide on R Data Import/Export (by the R Core Team) available at:\nhttp://cran.r-project.org/doc/manuals/r-release/R-data.html"
  },
  {
    "objectID": "03-basic-manipulations.html",
    "href": "03-basic-manipulations.html",
    "title": "3  Basic Manipulations with \"base\" Functions",
    "section": "",
    "text": "In this chapter you will learn about the different functions to do what I call basic manipulations. By “basic” I mean transforming and processing strings in such way that do not require the use of regular expressions. More advanced manipulations involve defining patterns of text and matching such patterns. This is the essential idea behind regular expressions, which is the content of part 3 in this book."
  },
  {
    "objectID": "03-basic-manipulations.html#basic-string-manipulations",
    "href": "03-basic-manipulations.html#basic-string-manipulations",
    "title": "3  Basic Manipulations with \"base\" Functions",
    "section": "3.1 Basic String Manipulations",
    "text": "3.1 Basic String Manipulations\nBesides creating and printing strings, there are a number of very handy functions in R for doing some basic manipulation of strings. In this section\nwe will review the following functions:\n\n\n\nFunction\nDescription\n\n\n\n\nnchar()\nnumber of characters\n\n\ntolower()\nconvert to lower case\n\n\ntoupper()\nconvert to upper case\n\n\ncasefold()\ncase folding\n\n\nchartr()\ncharacter translation\n\n\nabbreviate()\nabbreviation\n\n\nsubstring()\nsubstrings of a character vector\n\n\nsubstr()\nsubstrings of a character vector\n\n\n\n\n3.1.1 Count number of characters with nchar()\nOne of the main functions for manipulating character strings is nchar() which counts the number of characters in a string. In other words, nchar() provides the length of a string:\n\n# how many characters?\nnchar(c(\"How\", \"many\", \"characters?\"))\n\n[1]  3  4 11\n\n# how many characters?\nnchar(\"How many characters?\")\n\n[1] 20\n\n\nNotice that the white spaces between words in the second example are also counted as characters.\nIt is important not to confuse nchar() with length(). While the former gives us the number of characters, the later only gives the number of elements in a vector.\n\n# how many elements?\nlength(c(\"How\", \"many\", \"characters?\"))\n\n[1] 3\n\n# how many elements?\nlength(\"How many characters?\")\n\n[1] 1\n\n\n\n\n3.1.2 Convert to lower case with tolower()\nR comes with three functions for text casefolding.\n\ntolower()\ntoupper()\ncasefold()\n\nThe first function we’ll discuss is tolower() which converts any upper case characters into lower case:\n\n# to lower case\ntolower(c(\"aLL ChaRacterS in LoweR caSe\", \"ABCDE\"))\n\n[1] \"all characters in lower case\" \"abcde\"                       \n\n\n\n\n3.1.3 Convert to upper case with toupper()\nThe opposite function of tolower() is toupper. As you may guess, this function converts any lower case characters into upper case:\n\n# to upper case\ntoupper(c(\"All ChaRacterS in Upper Case\", \"abcde\"))\n\n[1] \"ALL CHARACTERS IN UPPER CASE\" \"ABCDE\"                       \n\n\n\n\n3.1.4 Upper or lower case conversion with casefold()\nThe third function for case-folding is casefold() which is a wrapper for both tolower() and toupper(). Its uasge has the following form:\ncasefold(x, upper = FALSE)\nBy default, casefold() converts all characters to lower case, but you can use the argument upper = TRUE to indicate the opposite (characters in upper case):\n\n# lower case folding\ncasefold(\"aLL ChaRacterS in LoweR caSe\")\n\n[1] \"all characters in lower case\"\n\n# upper case folding\ncasefold(\"All ChaRacterS in Upper Case\", upper = TRUE)\n\n[1] \"ALL CHARACTERS IN UPPER CASE\"\n\n\nI’ve found the case-folding functions to be very helpful when I write functions that take a character input which may be specified in lower or upper case, or perhaps as a mix of both cases. For instance, consider the function temp_convert() that takes a temperature value in Fahrenheit degress, and a character string indicating the name of the scale to be converted.\n\ntemp_convert <- function(deg = 1, to = \"celsius\") {\n  switch(to,\n         \"celsius\" = (deg - 32) * (5/9),\n         \"kelvin\" = (deg + 459.67) * (5/9),\n         \"reaumur\" = (deg - 32) * (4/9),\n         \"rankine\" = deg + 459.67)\n}\n\nHere is how you call temp_convert() to convert 10 Fahrenheit degrees into celsius degrees:\n\ntemp_convert(deg = 10, to = \"celsius\")\n\n[1] -12.22222\n\n\ntemp_convert() works fine when the argument to = 'celsius'. But what happens if you try temp_convert(30, 'Celsius') or temp_convert(30, 'CELSIUS')?\nTo have a more flexible function temp_convert() you can apply tolower() to the argument to, and in this way guarantee that the provided string by the user is always in lower case:\n\ntemp_convert <- function(deg = 1, to = \"celsius\") {\n  switch(tolower(to),\n         \"celsius\" = (deg - 32) * (5/9),\n         \"kelvin\" = (deg + 459.67) * (5/9),\n         \"reaumur\" = (deg - 32) * (4/9),\n         \"rankine\" = deg + 459.67)\n}\n\nNow all the following three calls are equivalent:\n\ntemp_convert(30, 'celsius')\ntemp_convert(30, 'Celsius')\ntemp_convert(30, 'CELSIUS')\n\n\n\n3.1.5 Character translation with chartr()\nThere’s also the function chartr() which stands for character translation. chartr() takes three arguments: an old string, a new string, and a character vector x:\nchartr(old, new, x)\nThe way chartr() works is by replacing the characters in old that appear in x by those indicated in new. For example, suppose we want to translate the letter \"a\" (lower case) with \"A\" (upper case) in the sentence \"This is a boring string\":\n\n# replace 'a' by 'A'\nchartr(\"a\", \"A\", \"This is a boring string\")\n\n[1] \"This is A boring string\"\n\n\nIt is important to note that old and new must have the same number of characters, otherwise you will get a nasty error message like this one:\n\n# incorrect use\nchartr(\"ai\", \"X\", \"This is a bad example\")\n\nError in chartr(\"ai\", \"X\", \"This is a bad example\"): 'old' is longer than 'new'\n\n\nHere’s a more interesting example with old = \"aei\" and new = \"\\#!?\". This implies that any 'a' in 'x' will be replaced by '\\#', any 'e' in 'x' will be replaced by '?', and any 'i' in 'x' will be replaced by '?':\n\n# multiple replacements\ncrazy <- c(\"Here's to the crazy ones\", \"The misfits\", \"The rebels\")\nchartr(\"aei\", \"#!?\", crazy)\n\n[1] \"H!r!'s to th! cr#zy on!s\" \"Th! m?sf?ts\"             \n[3] \"Th! r!b!ls\"              \n\n\n\n\n3.1.6 Abbreviate strings with abbreviate()\nAnother useful function for basic manipulation of character strings is abbreviate(). Its usage has the following structure:\nabbreviate(names.org, minlength = 4, dot = FALSE, strict = FALSE,\n            method = c(\"left.keep\", \"both.sides\"))\nAlthough there are several arguments, the main parameter is the character vector (names.org) which will contain the names that we want to abbreviate:\n\n# some color names\nsome_colors <- colors()[1:4]\nsome_colors\n\n[1] \"white\"         \"aliceblue\"     \"antiquewhite\"  \"antiquewhite1\"\n\n# abbreviate (default usage)\ncolors1 <- abbreviate(some_colors)\ncolors1\n\n        white     aliceblue  antiquewhite antiquewhite1 \n       \"whit\"        \"alcb\"        \"antq\"        \"ant1\" \n\n# abbreviate with 'minlength'\ncolors2 <- abbreviate(some_colors, minlength = 5)\ncolors2\n\n        white     aliceblue  antiquewhite antiquewhite1 \n      \"white\"       \"alcbl\"       \"antqw\"       \"antq1\" \n\n# abbreviate\ncolors3 <- abbreviate(some_colors, minlength = 3, method = \"both.sides\")\ncolors3\n\n        white     aliceblue  antiquewhite antiquewhite1 \n        \"wht\"         \"alc\"         \"ant\"         \"an1\" \n\n\nA common use for abbreviate() is when plotting names of objects or variables in a graphic. I will use the built-in data set mtcars to show you a simple example with a scatterplot between variables mpg and disp\n\nplot(mtcars$mpg, mtcars$disp, type = \"n\")\ntext(mtcars$mpg, mtcars$disp, rownames(mtcars))\n\n\n\n\nThe names of the cars are all over the plot. In this situation you may want to consider using abbreviate() to shrink the names of the cars and produce a less “crowded” plot:\n\nplot(mtcars$mpg, mtcars$disp, type = \"n\")\ntext(mtcars$mpg, mtcars$disp, abbreviate(rownames(mtcars)))\n\n\n\n\n\n\n3.1.7 Replace substrings with substr()\nOne common operation when working with strings is the extraction and replacement of some characters. There a various ways in which characters can be replaced. If the replacement is based on the positions that characters occupy in the string, you can use the functions substr() and substring()\nsubstr() extracts or replaces substrings in a character vector. Its usage has the following form:\nsubstr(x, start, stop)\nx is a character vector, start indicates the first element to be replaced, and stop indicates the last element to be replaced:\n\n# extract 'bcd'\nsubstr(\"abcdef\", 2, 4)\n\n[1] \"bcd\"\n\n# replace 2nd letter with hash symbol\nx <- c(\"may\", \"the\", \"force\", \"be\", \"with\", \"you\")\nsubstr(x, 2, 2) <- \"#\"\nx\n\n[1] \"m#y\"   \"t#e\"   \"f#rce\" \"b#\"    \"w#th\"  \"y#u\"  \n\n# replace 2nd and 3rd letters with happy face\ny = c(\"may\", \"the\", \"force\", \"be\", \"with\", \"you\")\nsubstr(y, 2, 3) <- \":)\"\ny\n\n[1] \"m:)\"   \"t:)\"   \"f:)ce\" \"b:\"    \"w:)h\"  \"y:)\"  \n\n# replacement with recycling\nz <- c(\"may\", \"the\", \"force\", \"be\", \"with\", \"you\")\nsubstr(z, 2, 3) <- c(\"#\", \"```\")\nz\n\n[1] \"m#y\"   \"t``\"   \"f#rce\" \"b`\"    \"w#th\"  \"y``\"  \n\n\n\n\n3.1.8 Replace substrings with substring()\nClosely related to substr() is the function substring() which extracts or replaces substrings in a character vector. Its usage has the following form:\nsubstring(text, first, last = 1000000L)\ntext is a character vector, first indicates the first element to be replaced, and last indicates the last element to be replaced:\n\n# same as 'substr'\nsubstring(\"ABCDEF\", 2, 4)\n\n[1] \"BCD\"\n\nsubstr(\"ABCDEF\", 2, 4)\n\n[1] \"BCD\"\n\n# extract each letter\nsubstring(\"ABCDEF\", 1:6, 1:6)\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\n\n# multiple replacement with recycling\ntext6 <- c(\"more\", \"emotions\", \"are\", \"better\", \"than\", \"less\")\nsubstring(text6, 1:3) <- c(\" \", \"zzz\")\ntext6\n\n[1] \" ore\"     \"ezzzions\" \"ar \"      \"zzzter\"   \"t an\"     \"lezz\""
  },
  {
    "objectID": "03-basic-manipulations.html#set-operations",
    "href": "03-basic-manipulations.html#set-operations",
    "title": "3  Basic Manipulations with \"base\" Functions",
    "section": "3.2 Set Operations",
    "text": "3.2 Set Operations\nR has dedicated functions for performing set operations on two given vectors. This implies that we can apply functions such as set union, intersection, difference, equality and membership, on \"character\" vectors.\n\n\n\nFunction\nDescription\n\n\n\n\nunion()\nset union\n\n\nintersect()\nintersection\n\n\nsetdiff()\nset difference\n\n\nsetequal()\nequal sets\n\n\nidentical()\nexact equality\n\n\nis.element()\nis element\n\n\n%in%()\ncontains\n\n\nsort()\nsorting\n\n\npaste(rep())\nrepetition\n\n\n\n\n3.2.1 Set union with union()\nLet’s start our reviewing of set functions with union(). As its name indicates, you can use `union()} when you want to obtain the elements of the union between two character vectors:\n\n# two character vectors\nset1 <- c(\"some\", \"random\", \"words\", \"some\")\nset2 <- c(\"some\", \"many\", \"none\", \"few\")\n\n# union of set1 and set2\nunion(set1, set2)\n\n[1] \"some\"   \"random\" \"words\"  \"many\"   \"none\"   \"few\"   \n\n\nNotice that union() discards any duplicated values in the provided vectors. In the previous example the word \"some\" appears twice inside set1 but it appears only once in the union. In fact all the set operation functions will discard any duplicated values.\n\n\n3.2.2 Set intersection with intersect()\nSet intersection is performed with the function intersect(). You can use this function when you wish to get those elements that are common to both vectors:\n\n# two character vectors\nset3 <- c(\"some\", \"random\", \"few\", \"words\")\nset4 <- c(\"some\", \"many\", \"none\", \"few\")\n\n# intersect of set3 and set4\nintersect(set3, set4)\n\n[1] \"some\" \"few\" \n\n\n\n\n3.2.3 Set difference with setdiff()\nRelated to the intersection, you might be interested in getting the difference of the elements between two character vectors. This can be done with setdiff():\n\n# two character vectors\nset5 <- c(\"some\", \"random\", \"few\", \"words\")\nset6 <- c(\"some\", \"many\", \"none\", \"few\")\n\n# difference between set5 and set6\nsetdiff(set5, set6)\n\n[1] \"random\" \"words\" \n\n\n\n\n3.2.4 Set equality with setequal()\nThe function setequal() allows you to test the equality of two character vectors. If the vectors contain the same elements, setequal() returns TRUE (FALSE otherwise)\n\n# three character vectors\nset7 <- c(\"some\", \"random\", \"strings\")\nset8 <- c(\"some\", \"many\", \"none\", \"few\")\nset9 <- c(\"strings\", \"random\", \"some\")\n\n# set7 == set8?\nsetequal(set7, set8)\n\n[1] FALSE\n\n# set7 == set9?\nsetequal(set7, set9)\n\n[1] TRUE\n\n\n\n\n3.2.5 Exact equality with identical()\nSometimes setequal() is not always what we want to use. It might be the case that you want to test whether two vectors are exactly equal (element by element). For instance, testing if set7 is exactly equal to set9. Although both vectors contain the same set of elements, they are not exactly the same vector. Such test can be performed with the function identical()\n\n# set7 identical to set7?\nidentical(set7, set7)\n\n[1] TRUE\n\n# set7 identical to set9?\nidentical(set7, set9)\n\n[1] FALSE\n\n\nIf you consult the help documentation of identical(), you will see that this function is the “safe and reliable way to test two objects for being exactly equal”.\n\n\n3.2.6 Element contained with is.element()\nIf you wish to test if an element is contained in a given set of character strings you can do so with is.element():\n\n# three vectors\nset10 <- c(\"some\", \"stuff\", \"to\", \"play\", \"with\")\nelem1 <- \"play\"\nelem2 <- \"crazy\"\n\n# elem1 in set10?\nis.element(elem1, set10)\n\n[1] TRUE\n\n# elem2 in set10?\nis.element(elem2, set10)\n\n[1] FALSE\n\n\nAlternatively, you can use the binary operator %in% to test if an element is contained in a given set. The function %in% returns TRUE if the first operand is contained in the second, and it returns FALSE otherwise:\n\n# elem1 in set10?\nelem1 %in% set10\n\n[1] TRUE\n\n# elem2 in set10?\nelem2 %in% set10\n\n[1] FALSE\n\n\n\n\n3.2.7 Sorting with sort()\nThe function sort() allows you to sort the elements of a vector, either in increasing order (by default) or in decreasing order using the argument decreasing:\n\nset11 = c(\"today\", \"produced\", \"example\", \"beautiful\", \"a\", \"nicely\")\n\n# sort (decreasing order)\nsort(set11)\n\n[1] \"a\"         \"beautiful\" \"example\"   \"nicely\"    \"produced\"  \"today\"    \n\n# sort (increasing order)\nsort(set11, decreasing = TRUE)\n\n[1] \"today\"     \"produced\"  \"nicely\"    \"example\"   \"beautiful\" \"a\"        \n\n\nIf you have alpha-numeric strings, sort() will put the numbers first when sorting in increasing order:\n\nset12 = c(\"today\", \"produced\", \"example\", \"beautiful\", \"1\", \"nicely\")\n\n# sort (decreasing order)\nsort(set12)\n\n[1] \"1\"         \"beautiful\" \"example\"   \"nicely\"    \"produced\"  \"today\"    \n\n# sort (increasing order)\nsort(set12, decreasing = TRUE)\n\n[1] \"today\"     \"produced\"  \"nicely\"    \"example\"   \"beautiful\" \"1\"        \n\n\n\n\n3.2.8 Repetition with paste(rep())\nA very common operation with strings is replication, that is, given a string we want to replicate it several times. Although there is no single function in R for that purpose, we can combine paste() and rep() like so:\n\n# repeat \"x\" 4 times\npaste(rep(\"x\", 4), collapse = '')\n\n[1] \"xxxx\""
  },
  {
    "objectID": "04-stringr-basics.html",
    "href": "04-stringr-basics.html",
    "title": "4  Basic Manipulations with \"stringr\" Functions",
    "section": "",
    "text": "As we saw in the previous chapters, R provides a useful range of functions for basic string processing and manipulations of \"character\" data. Most of the times these functions are enough and they will allow us to get our job done. Sometimes, however, they have an awkward behavior.\nAs an example, consider the function paste(). The default separator is a blank space, which more often than not is what we want to use. But that’s secondary. The really annoying thing is when we want to paste things that include zero length arguments. How does paste() behave in those cases? See below:\nNotice the output from the last example (the ugly one). The objects NULL and character(0) have zero length, yet when included inside paste() they are treated as an empty string \"\". Wouldn’t be good if paste() removed zero length arguments? Sadly, there’s nothing we can do to change nchar() and paste(). But fear not. There is a very nice package that solves these problems and provides several functions for carrying out consistent string processing."
  },
  {
    "objectID": "04-stringr-basics.html#package-stringr",
    "href": "04-stringr-basics.html#package-stringr",
    "title": "4  Basic Manipulations with \"stringr\" Functions",
    "section": "4.1 Package \"stringr\"",
    "text": "4.1 Package \"stringr\"\nThanks to Hadley Wickham and company, we have the package \"stringr\" that adds more functionality to the base functions for handling strings in R. According to the description of the package\nhttp://cran.r-project.org/web/packages/stringr/index.html\n\n\"stringr\" is a set of simple wrappers that make R’s string functions more consistent, simpler and easier to use. It does this by ensuring that: function and argument names (and positions) are consistent, all functions deal with NA’s and zero length character appropriately, and the output data structures from each function matches the input data structures of other functions.”\n\nTo install \"stringr\" use the function install.packages(). Once installed, load it to your current session with library():\n\n# installing 'stringr'\ninstall.packages(\"stringr\")\n\n# load 'stringr'\nlibrary(stringr)"
  },
  {
    "objectID": "04-stringr-basics.html#basic-string-operations",
    "href": "04-stringr-basics.html#basic-string-operations",
    "title": "4  Basic Manipulations with \"stringr\" Functions",
    "section": "4.2 Basic String Operations",
    "text": "4.2 Basic String Operations\n\"stringr\" provides functions for both 1) basic manipulations and 2) for regular expression operations. In this chapter we cover those functions that have to do with basic manipulations.\nThe following table contains the \"stringr\" functions for basic string operations:\n\n\n\n\n\n\n\n\nFunction\nDescription\nSimilar to\n\n\n\n\nstr_c()\nstring concatenation\npaste()\n\n\nstr_length()\nnumber of characters\nnchar()\n\n\nstr_sub()\nextracts substrings\nsubstring()\n\n\nstr_dup()\nduplicates characters\nnone\n\n\nstr_trim()\nremoves leading and trailing whitespace\nnone\n\n\nstr_pad()\npads a string\nnone\n\n\nstr_wrap()\nwraps a string paragraph\nstrwrap()\n\n\nstr_trim()\ntrims a string\nnone\n\n\n\nNotice that all functions start with \"str_\" followed by a term associated to the task they perform. For example, str_length() gives you the number (i.e. length) of characters in a string. In addition, some functions are designed to provide a better alternative to already existing functions. This is the case of str_length() which is intended to be a substitute of nchar(). Other functions, however, don’t have a corresponding alternative such as str_dup() which allows you to duplicate characters.\n\n4.2.1 Concatenating with str_c()\nLet’s begin with str_c(). This function is equivalent to paste() but instead of using the white space as the default separator, str_c() uses the empty string \"\" which is a more common separator when pasting strings:\n\n# default usage\nstr_c(\"May\", \"The\", \"Force\", \"Be\", \"With\", \"You\")\n\n[1] \"MayTheForceBeWithYou\"\n\n# removing zero length objects\nstr_c(\"May\", \"The\", \"Force\", NULL, \"Be\", \"With\", \"You\", character(0))\n\ncharacter(0)\n\n\nObserve another major difference between str_c() and paste(): zero length arguments like NULL and character(0) are silently removed by str_c().\nIf you want to change the default separator, you can do that as usual by specifying the argument sep:\n\n# changing separator\nstr_c(\"May\", \"The\", \"Force\", \"Be\", \"With\", \"You\", .sep = \"_\")\n\n[1] \"MayTheForceBeWithYou_\"\n\n# synonym function 'str_glue'\nstr_glue(\"May\", \"The\", \"Force\", \"Be\", \"With\", \"You\", .sep = \"_\")\n\nMay_The_Force_Be_With_You\n\n\nAs you can see from the previous examples, an alternative for str _() is str_glue() with the argument .sep.\n\n\n4.2.2 Number of characters with str_length()\nAs we’ve mentioned before, the function str_length() is equivalent to nchar(). Both functions return the number of characters in a string, that is, the length of a string (do not confuse it with the length() of a vector). Compared to nchar(), str_length() has a more consistent behavior when dealing with NA values. Instead of giving NA a length of 2, str_length() preserves missing values just as NAs.\n\n# some text (NA included)\nsome_text <- c(\"one\", \"two\", \"three\", NA, \"five\")\n\n# compare 'str_length' with 'nchar'\nnchar(some_text)\n\n[1]  3  3  5 NA  4\n\nstr_length(some_text)\n\n[1]  3  3  5 NA  4\n\n\nIn addition, str_length() has the nice feature that it converts factors to characters, something that nchar() is not able to handle:\n\nsome_factor <- factor(c(1,1,1,2,2,2), labels = c(\"good\", \"bad\"))\nsome_factor\n\n[1] good good good bad  bad  bad \nLevels: good bad\n\n# try 'nchar' on a factor\nnchar(some_factor)\n\nError in nchar(some_factor): 'nchar()' requires a character vector\n\n# now compare it with 'str_length'\nstr_length(some_factor)\n\n[1] 4 4 4 3 3 3\n\n\n\n\n4.2.3 Substring with str_sub()\nTo extract substrings from a character vector stringr provides str_sub() which is equivalent to substring(). The function str_sub() has the following usage form:\nstr_sub(string, start = 1L, end = -1L)\nThe three arguments in the function are: a string vector, a start value indicating the position of the first character in substring, and an end value indicating the position of the last character. Here’s a simple example with a single string in which characters from 1 to 5 are extracted:\n\nlorem <- \"Lorem Ipsum\"\n\n# apply 'str_sub'\nstr_sub(lorem, start = 1, end = 5)\n\n[1] \"Lorem\"\n\n# equivalent to 'substring'\nsubstring(lorem, first = 1, last = 5)\n\n[1] \"Lorem\"\n\n# another example\nstr_sub(\"adios\", 1:3)\n\n[1] \"adios\" \"dios\"  \"ios\"  \n\n\nAn interesting feature of str_sub() is its ability to work with negative indices in the start and end positions. When we use a negative position, str_sub() counts backwards from last character:\n\nresto = c(\"brasserie\", \"bistrot\", \"creperie\", \"bouchon\")\n\n# 'str_sub' with negative positions\nstr_sub(resto, start = -4, end = -1)\n\n[1] \"erie\" \"trot\" \"erie\" \"chon\"\n\n# compared to substring (useless)\nsubstring(resto, first = -4, last = -1)\n\n[1] \"\" \"\" \"\" \"\"\n\n\nSimilar to substring(), we can also give str_sub() a set of positions which will be recycled over the string. But even better, we can give str_sub() a negative sequence, something that substring() ignores:\n\n# extracting sequentially\nstr_sub(lorem, seq_len(nchar(lorem)))\n\n [1] \"Lorem Ipsum\" \"orem Ipsum\"  \"rem Ipsum\"   \"em Ipsum\"    \"m Ipsum\"    \n [6] \" Ipsum\"      \"Ipsum\"       \"psum\"        \"sum\"         \"um\"         \n[11] \"m\"          \n\nsubstring(lorem, seq_len(nchar(lorem)))\n\n [1] \"Lorem Ipsum\" \"orem Ipsum\"  \"rem Ipsum\"   \"em Ipsum\"    \"m Ipsum\"    \n [6] \" Ipsum\"      \"Ipsum\"       \"psum\"        \"sum\"         \"um\"         \n[11] \"m\"          \n\n# reverse substrings with negative positions\nstr_sub(lorem, -seq_len(nchar(lorem)))\n\n [1] \"m\"           \"um\"          \"sum\"         \"psum\"        \"Ipsum\"      \n [6] \" Ipsum\"      \"m Ipsum\"     \"em Ipsum\"    \"rem Ipsum\"   \"orem Ipsum\" \n[11] \"Lorem Ipsum\"\n\nsubstring(lorem, -seq_len(nchar(lorem)))\n\n [1] \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\"\n [6] \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\" \"Lorem Ipsum\"\n[11] \"Lorem Ipsum\"\n\n\nWe can use str_sub() not only for extracting subtrings but also for replacing substrings:\n\n# replacing 'Lorem' with 'Nullam'\nlorem <- \"Lorem Ipsum\"\nstr_sub(lorem, 1, 5) <- \"Nullam\"\nlorem\n\n[1] \"Nullam Ipsum\"\n\n# replacing with negative positions\nlorem <- \"Lorem Ipsum\"\nstr_sub(lorem, -1) <- \"Nullam\"\nlorem\n\n[1] \"Lorem IpsuNullam\"\n\n# multiple replacements \nlorem <- \"Lorem Ipsum\"\nstr_sub(lorem, c(1,7), c(5,8)) <- c(\"Nullam\", \"Enim\")\nlorem\n\n[1] \"Nullam Ipsum\"  \"Lorem Enimsum\"\n\n\n\n\n4.2.4 Duplication with str_dup()\nA common operation when handling characters is duplication. The problem is that R doesn’t have a specific function for that purpose. But stringr does: str_dup() duplicates and concatenates strings within a character vector. Its usage requires two arguments:\nstr_dup(string, times)\nThe first input is the string that you want to dplicate. The second input, times, is the number of times to duplicate each string:\n\n# default usage\nstr_dup(\"hola\", 3)\n\n[1] \"holaholahola\"\n\n# use with differetn 'times'\nstr_dup(\"adios\", 1:3)\n\n[1] \"adios\"           \"adiosadios\"      \"adiosadiosadios\"\n\n# use with a string vector\nwords <- c(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\")\nstr_dup(words, 2)\n\n[1] \"loremlorem\" \"ipsumipsum\" \"dolordolor\" \"sitsit\"     \"ametamet\"  \n\nstr_dup(words, 1:5)\n\n[1] \"lorem\"                \"ipsumipsum\"           \"dolordolordolor\"     \n[4] \"sitsitsitsit\"         \"ametametametametamet\"\n\n\n\n\n4.2.5 Padding with str_pad()\nAnother handy function that we can find in stringr is str_pad() for padding a string. Its default usage has the following form:\nstr_pad(string, width, side = \"left\", pad = \" \")\nThe idea of str_pad() is to take a string and pad it with leading or trailing characters to a specified total width. The default padding character is a space (pad = \" \"), and consequently the returned string will appear to be either left-aligned (side = \"left\"), right-aligned (side = \"right\"), or both (side = \"both\").\nLet’s see some examples:\n\n# default usage\nstr_pad(\"hola\", width = 7)\n\n[1] \"   hola\"\n\n# pad both sides\nstr_pad(\"adios\", width = 7, side = \"both\")\n\n[1] \" adios \"\n\n# left padding with '#'\nstr_pad(\"hashtag\", width = 8, pad = \"#\")\n\n[1] \"#hashtag\"\n\n# pad both sides with '-'\nstr_pad(\"hashtag\", width = 9, side = \"both\", pad = \"-\")\n\n[1] \"-hashtag-\"\n\n\n\n\n4.2.6 Wrapping with str_wrap()\nThe function str_wrap() is equivalent to strwrap() which can be used to wrap a string to format paragraphs. The idea of wrapping a (long) string is to first split it into paragraphs according to the given width, and then add the specified indentation in each line (first line with indent, following lines with exdent). Its default usage has the following form:\nstr_wrap(string, width = 80, indent = 0, exdent = 0)\nFor instance, consider the following quote (from Douglas Adams) converted into a paragraph:\n\n# quote (by Douglas Adams)\nsome_quote <- c(\n  \"I may not have gone\",\n  \"where I intended to go,\", \n  \"but I think I have ended up\",\n  \"where I needed to be\")\n\n# some_quote in a single paragraph\nsome_quote <- paste(some_quote, collapse = \" \")\n\nNow, say you want to display the text of some_quote within some pre-specified column width (e.g. width of 30). You can achieve this by applying str_wrap() and setting the argument width = 30\n\n# display paragraph with width=30\ncat(str_wrap(some_quote, width = 30))\n\nI may not have gone where I\nintended to go, but I think I\nhave ended up where I needed\nto be\n\n\nBesides displaying a (long) paragraph into several lines, you may also wish to add some indentation. Here’s how you can indent the first line, as well as the following lines:\n\n# display paragraph with first line indentation of 2\ncat(str_wrap(some_quote, width = 30, indent = 2), \"\\n\")\n\n  I may not have gone where I\nintended to go, but I think I\nhave ended up where I needed\nto be \n\n# display paragraph with following lines indentation of 3\ncat(str_wrap(some_quote, width = 30, exdent = 3), \"\\n\")\n\nI may not have gone where I\n   intended to go, but I think\n   I have ended up where I\n   needed to be \n\n\n\n\n4.2.7 Trimming with str_trim()\nOne of the typical tasks of string processing is that of parsing a text into individual words. Usually, you end up with words that have blank spaces, called whitespaces, on either end of the word. In this situation, you can use the str_trim() function to remove any number of whitespaces at the ends of a string. Its usage requires only two arguments:\nstr_trim(string, side = \"both\")\nThe first input is the string to be strimmed, and the second input indicates the side on which the whitespace will be removed.\nConsider the following vector of strings, some of which have whitespaces either on the left, on the right, or on both sides. Here’s what str_trim() would do to them under different settings of side\n\n# text with whitespaces\nbad_text <- c(\"This\", \" example \", \"has several   \", \"   whitespaces \")\n\n# remove whitespaces on the left side\nstr_trim(bad_text, side = \"left\")\n\n[1] \"This\"           \"example \"       \"has several   \" \"whitespaces \"  \n\n# remove whitespaces on the right side\nstr_trim(bad_text, side = \"right\")\n\n[1] \"This\"           \" example\"       \"has several\"    \"   whitespaces\"\n\n# remove whitespaces on both sides\nstr_trim(bad_text, side = \"both\")\n\n[1] \"This\"        \"example\"     \"has several\" \"whitespaces\"\n\n\n\n\n4.2.8 Word extraction with word()\nWe end this chapter describing the word() function that is designed to extract words from a sentence:\nword(string, start = 1L, end = start, sep = fixed(\" \"))\nThe way in which you use word() is by passing it a string, together with a start position of the first word to extract, and an end position of the last word to extract. By default, the separator sep used between words is a single space.\nLet’s see some examples:\n\n# some sentence\nchange <- c(\"Be the change\", \"you want to be\")\n\n# extract first word\nword(change, 1)\n\n[1] \"Be\"  \"you\"\n\n# extract second word\nword(change, 2)\n\n[1] \"the\"  \"want\"\n\n# extract last word\nword(change, -1)\n\n[1] \"change\" \"be\"    \n\n# extract all but the first words\nword(change, 2, -1)\n\n[1] \"the change\" \"want to be\"\n\n\n\"stringr\" has more functions but we’ll discuss them in the chapters about regular expressions."
  },
  {
    "objectID": "05-printing.html",
    "href": "05-printing.html",
    "title": "5  Formatting Text and Numbers",
    "section": "",
    "text": "A common task when working with character strings involves printing and displaying them on the screen or on a file. In this chapter you will learn about the different functions and options in R to print strings in a wide variety of common—and not so common—formats."
  },
  {
    "objectID": "05-printing.html#printing-characters",
    "href": "05-printing.html#printing-characters",
    "title": "5  Formatting Text and Numbers",
    "section": "5.1 Printing Characters",
    "text": "5.1 Printing Characters\nR provides a series of functions for printing strings. Some of the printing functions are useful when creating print methods for programmed objects’ classes. Other functions are useful for printing output either in the R console or to a given file. In this chapter we will describe the following print-related functions:\n\n\n\nFunction\nDescription\n\n\n\n\nprint()\ngeneric printing\n\n\nnoquote()\nprint with no quotes\n\n\ncat()\nconcatenation\n\n\nformat()\nspecial formats\n\n\ntoString()\nconvert to string\n\n\nsprintf()\nC-style printing\n\n\n\n\n5.1.1 Generic printing with print()\nThe workhorse printing function in R is print(). As its names indicates, this function prints its argument on the R console:\n\n# text string\nmy_string <- \"programming with data is fun\"\n\nprint(my_string)\n\n[1] \"programming with data is fun\"\n\n\nTo be more precise, print() is a generic function, which means that you should use this function when creating printing methods for programmed classes.\nAs you can see from the previous example, print() displays text in quoted form by default. If you want to print character strings with no quotes you can set the argument quote = FALSE\n\n# print without quotes\nprint(my_string, quote = FALSE)\n\n[1] programming with data is fun\n\n\nThe output produced by print() can be customized with various optional arguments. However, the way in which print() displays objects is rather limited. To get more printing variety there is a number of more flexible functions that we can use.\n\nWhen to use print()\nWhen you type the name of an obbject in the R console, R calls the corresponding print method associated to the class of the object. If the object is a \"data.frame\", then R will dispatch the method print.data.frame and display the output on screen accordingly.\nMost of the times you don’t really need to invoke print(). Usually, simply typing the name of the object will suffice. So when do you actually call print()? You use print() when your code is inside an R expression (i.e. code inside curly braces { }) and you want to see the results of one or more computational steps. Typical examples that require an explicit call to print() is when you are interested in looking at some value within a loop, or a conditional structure.\nConsider the following dummy for loop. It iterates five times, each time adding 1 to the value of the iterator i:\n\nfor (i in 1:5) {\n  i + 1\n}\n\nThe above code works and R executes the additions, but nothing is displayed on the console. This is because the command i + 1 forms part of an R expression, that is, it is within the braces { }. To be able to see the actual computations you should call print() like so:\n\nfor (i in 1:5) {\n  print(i + 1)\n}\n\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n\n\n\n\n\n5.1.2 Unquoted characters with noquote()\nWe know that we can print text without quotes using print() with its argument quote = FALSE. An alternative option for achieving a similar output is by using noquote(). As its names implies, this function prints character strings with no quotes:\n\n# noquote\nnoquote(my_string)\n\n[1] programming with data is fun\n\n\nTo be more precise, noquote() creates a character object of class \"noquote\" which always gets displayed without quotes:\n\n# class noquote\nno_quotes = noquote(c(\"some\", \"quoted\", \"text\", \"!%^(&=\"))\n\n# display\nno_quotes\n\n[1] some   quoted text   !%^(&=\n\n# check class\nclass(no_quotes)\n\n[1] \"noquote\"\n\n# test character\nis.character(no_quotes)\n\n[1] TRUE\n\n# no quotes even when subscripting \nno_quotes[2:3]\n\n[1] quoted text  \n\n\n\n\n5.1.3 Concatenate and print with cat()\nAnother very useful function is cat() which allows you to concatenate objects and print them either on screen or to a file. Its usage has the following structure:\ncat(..., file = \"\", sep = \" \", fill = FALSE, labels = NULL, append = FALSE)\nThe argument ... implies that cat() accepts several types of R objects (typically vectors). However, when we pass numeric and/or complex vectors, they are automatically converted to character strings by cat(). By default, the strings are concatenated with a space character as separator. This can be modified with the sep argument.\nIf you use cat() with only one single string, you get a similar (although not identical) result as noquote():\n\n# simply print with 'cat()'\ncat(my_string)\n\nprogramming with data is fun\n\n\nAs you can see, cat() prints its arguments without quotes. In essence, cat() simply displays its content (on screen or in a file). Compared to noquote(), cat() does not print the numeric line indicator ([1] in this case).\nThe usefulness of cat() is when we have two or more strings that we want to concatenate:\n\n# concatenate and print\ncat(my_string, \"with R\")\n\nprogramming with data is fun with R\n\n\nYou can use the argument sep to indicate a chacracter vector that will be included to separate the concatenated elements:\n\n# especifying 'sep'\ncat(my_string, \"with R\", sep=\" =) \")\n\nprogramming with data is fun =) with R\n\n# another example\ncat(1:10, sep = \"-\")\n\n1-2-3-4-5-6-7-8-9-10\n\n\nWhen we pass vectors to cat(), each of the elements are treated as though they were separate arguments:\n\n# first four months\ncat(month.name[1:4], sep = \" \")\n\nJanuary February March April\n\n# first four months\ncat(month.name[1:4], sep = \"-\")\n\nJanuary-February-March-April\n\n# first four months\ncat(month.name[1:4], sep = \"\")\n\nJanuaryFebruaryMarchApril\n\n\nThe argument fill allows us to break long strings; this is achieved when we specify the string width with an integer number:\n\n# fill = 30\ncat(\"Loooooooooong strings\", \"can be displayed\", \"in a nice format\", \n    \"by using the 'fill' argument\", fill = 30)\n\nLoooooooooong strings \ncan be displayed \nin a nice format \nby using the 'fill' argument\n\n\nLast but not least, we can specify a file output in cat(). For instance, let’s suppose that we want to save the output in the file output.txt located in our working directory. This is done by specifying the file argument:\n\n# cat with output in a given file\ncat(my_string, \"with R\", file = \"output.txt\")\n\n\n\n5.1.4 Encoding strings with format()\nThe function format() allows you to format an R object for pretty printing. Essentially, format() treats the elements of a vector as character strings using a common format. This is especially useful when printing numbers and quantities under different formats.\n\n# default usage\nformat(13.7)\n\n[1] \"13.7\"\n\n# another example\nformat(13.12345678)\n\n[1] \"13.12346\"\n\n\nSome useful arguments used in format():\n\nwidth the (minimum) width of strings produced\ntrim if set to TRUE there is no padding with spaces\njustify controls how padding takes place for strings. Takes the values \"left\", \"right\", \"centre\", \"none\"\n\nFor controling the printing of numbers, use these arguments:\n\ndigits The number of digits to the right of the decimal place.\nscientific use TRUE for scientific notation, FALSE for standard notation\n\n\n# use of 'nsmall'\nformat(13.7, nsmall = 3)\n\n[1] \"13.700\"\n\n# use of 'digits'\nformat(c(6.0, 13.1), digits = 2)\n\n[1] \" 6\" \"13\"\n\n# use of 'digits' and 'nsmall'\nformat(c(6.0, 13.1), digits = 2, nsmall = 1)\n\n[1] \" 6.0\" \"13.1\"\n\n\nBy default, format() pads the strings with spaces so that they all have the same length.\n\n# justify options\nformat(c(\"A\", \"BB\", \"CCC\"), width = 5, justify = \"centre\")\n\n[1] \"  A  \" \" BB  \" \" CCC \"\n\nformat(c(\"A\", \"BB\", \"CCC\"), width = 5, justify = \"left\")\n\n[1] \"A    \" \"BB   \" \"CCC  \"\n\nformat(c(\"A\", \"BB\", \"CCC\"), width = 5, justify = \"right\")\n\n[1] \"    A\" \"   BB\" \"  CCC\"\n\nformat(c(\"A\", \"BB\", \"CCC\"), width = 5, justify = \"none\")\n\n[1] \"A\"   \"BB\"  \"CCC\"\n\n# digits\nformat(1/1:5, digits = 2)\n\n[1] \"1.00\" \"0.50\" \"0.33\" \"0.25\" \"0.20\"\n\n# use of 'digits', widths and justify\nformat(format(1/1:5, digits = 2), width = 6, justify = \"c\")\n\n[1] \" 1.00 \" \" 0.50 \" \" 0.33 \" \" 0.25 \" \" 0.20 \"\n\n\nFor printing large quantities with a sequenced format we can use the arguments big.mark or big.interval. For instance, here is how we can print a number with sequences separated by a comma \",\"\n\n# big.mark\nformat(123456789, big.mark = \",\")\n\n[1] \"123,456,789\""
  },
  {
    "objectID": "06-sprintf.html",
    "href": "06-sprintf.html",
    "title": "6  C-style Formatting",
    "section": "",
    "text": "R comes with the sprintf() function that provides string formatting like in the C language. To be more precise, this function is a wrapper for the C library function of the same name. In many other programming languages, this type of printing is known as printf which stands for print formatting. Simply put, sprintf() allows you to create strings as output using formatted data.\nThe function sprintf() requires using a special syntax that may look awkward the first time you use it. Here is one example:\nHow does sprintf() work? The first argument of this function is a character vector of one element that contains the text to be formatted. Observe that inside the text there are various percent symbols % followed by the letter s. Each % is referred to as a slot, which is basically a placeholder for a variable that will be formatted. The rest of the inputs passed to sprintf() are the values that will be used in each of the slots.\nThe string in the previous example contains three slots of the same type, %s, and the subsequent arguments are numbers 8, 0, and 5. Each number is used as a value for each slot. The letter s indicates that the formatted variable is specified as a string.\nMost of the times you won’t use sprintf() like in the example above. Instead, what you will pass are variables containing different values:"
  },
  {
    "objectID": "06-sprintf.html#c-style-formatting-options",
    "href": "06-sprintf.html#c-style-formatting-options",
    "title": "6  C-style Formatting",
    "section": "6.1 C-style Formatting Options",
    "text": "6.1 C-style Formatting Options\nThe string format %s is just one of a larger list of available formatting options. The following table shows the most common formatting specifications:\n\n\n\nNotation\nDescription\n\n\n\n\n%s\na string\n\n\n%d\nan integer\n\n\n%0xd\nan integer padded with x leading zeros\n\n\n%f\ndecimal notation with six decimals\n\n\n%.xf\nfloating point number with x digits after decimal point\n\n\n%e\ncompact scientific notation, e in the exponent\n\n\n%E\ncompact scientific notation, E in the exponent\n\n\n%g\ncompact decimal or scientific notation (with e)\n\n\n\n\n6.1.1 Format Slot Syntax\nThe full syntax for a format slot is defined by:\n%[parameter][flags][width][.precision][length]type\nThe percent symbol, %, as we said, indicates a placeholder or slot.\nThe parameter field is an optional field that can take the value n$ in which n is the number of the variable to display, allowing the variables provided to be used multiple times, using varying format specifiers or in different orders.\n\nsprintf(\"The second number is %2$d, the first number is %1$d\", 2, 1)\n\n[1] \"The second number is 1, the first number is 2\"\n\n\nThe flags field can be zero or more (in any order) of:\n\n- (minus) Left-align the output of this placeholder.\n+ (plus) Prepends a plus for positive signed-numeric types.\n' ' (space) Prepends a space for positive signed-numeric types.\n0 (zero) When the ‘width’ option is specified, prepends zeros for numeric types.\n# (hash) Alternate form:\n\nfor g and G types, trailing zeros are not removed.\nfor f, F, e, E, g, G types, the output always contain a decimal point.\nfor o, x, X types, the text 0, 0x, 0X, respectively, is prepended to non-zero numbers.\n\n\nThe width field is an optional field that you use to specify a minimum number of characters to output, and is typically used to pad fixed-width fields in tabulated output, where the fields would otherwise be smaller, although it does not cause truncation of oversized fields.\n\nsprintf(\"%*d\", 5, 10)\n\n[1] \"   10\"\n\n\nThe precision field usually specifies a maximum limit on the output, depending on the particular formatting type.\n\nsprintf(\"%.*s\", 3, \"abcdef\")\n\n[1] \"abc\"\n\n\nThe length field is also optional, and can be any of:\nThe most important field is the type field.\n\n%: Prints a literal % character (this type doesn’t accept any flags, width, precision, length fields).\nd, i: integer value as signed decimal number.\nf: double value in normal fixed-point notation.\ne, E: double value in standard form.\ng, G: double value in either normal or exponential notation.\nx, X: unsigned integer as a hexadecimal number. x uses lower case, while X uses upper case.\no: unsigned integer in octal notation.\ns: null terminated string.\na, A: double value in hexadecimal notation\n\n\n\n6.1.2 Example: basic sprintf()\nLet’s begin with a minimal example to explore the different formatting options of sprintf(). Consider a real fraction like 1/6; in R the default output of this fraction will be:\n\n1 / 6\n\n[1] 0.1666667\n\n\nNotice that 1/6 is printed with seven decimal digits. The number 1/6 is actually an irrational number and so the computer needs to round it to some number of decimal digits. You can modify the default printing format in several ways. One option is to display only six decimal digits with the %f option:\n\n# print 6 decimals\nsprintf('%f', 1/6)\n\n[1] \"0.166667\"\n\n\nBut you can also specify a different number of decimal digits, say 3. This can be achieved specifying an option of %.3f:\n\n# print 3 decimals\nsprintf('%.3f', 1/6)\n\n[1] \"0.167\"\n\n\nThe table below shows six different outputs for 1/6\n\n\n\nNotation\nOutput\n\n\n\n\n%s\n0.166666666666667\n\n\n%f\n0.166667\n\n\n%.3f\n0.167\n\n\n%e\n1.666667e-01\n\n\n%E\n1.666667E-01\n\n\n%g\n0.166667\n\n\n\nWhen would you use sprintf()? Everytime you produce output text. Some cases include:\n\nexporting output to some file.\nprinting output on console.\nforming new strings.\n\n\n\n6.1.3 Example: File Names\nWhen working on data analysis projects, it is common to generate different files with similar names (e.g. either for creating images, or data files, or documents). Imagine that you need to generate the names of 3 data files (with .csv extension). All the files have the same prefix name but each of them has a different number: data01.csv, data02.csv, and data03.csv. One naive solution to generate a character vector with these names in R would be to write something like this:\n\nfile_names <- c('data01.csv', 'data02.csv', 'data03.csv')\n\nInstead of writing each file name, you can generate the vector file_names in a more efficient way taking advantage of the vectorized nature of paste0():\n\nfile_names <- paste0('data0', 1:3, '.csv')\n\nfile_names\n\n[1] \"data01.csv\" \"data02.csv\" \"data03.csv\"\n\n\nNow imagine that you need to generate 100 file names numbered from 01, 02, 03, to 100. You could write a vector with 100 file names but it’s going to take you a while. A preferable solution is to use paste0() like in the approach of the previous example. In this case however, you would need to create two separate vectors—one with numbers 01 to 09, and another one with numbers 10 to 100—and then concatenate them in one single vector:\n\nfiles1 <- paste0('data0', 1:9, '.csv')\nfiles2 <- paste0('data', 10:100, '.csv')\nfile_names <- c(files1, files2)\n\nInstead of using paste0() to create two vectors, you can use sprintf() with the %0xd option to indicate that an integer should be padded with x leading zeros. For instance, the first nine file names can be generated as:\n\nsprintf('data%02d.csv', 1:9)\n\n[1] \"data01.csv\" \"data02.csv\" \"data03.csv\" \"data04.csv\" \"data05.csv\"\n[6] \"data06.csv\" \"data07.csv\" \"data08.csv\" \"data09.csv\"\n\n\nTo generate the 100 file names do:\n\nfile_names <- sprintf('data%02d.csv', 1:100)\n\nThe first nine elements in file_names will include a leading zero before the integer; the following elements will not include the leading zero.\n\n\n6.1.4 Example: Fahrenheit to Celsius\nThis example involves working on a function to convert Fahrenheit degrees into Celsius degrees. The conversion formula is:\n\\[\nCelsius = (Fahrenheit - 32) \\times \\frac{5}{9}\n\\]\nYou can define a simple function to_celsius() that takes one argument, temp, which is a number representing temperature in Fahrenheit degrees. This function will return the temperature in Celsius degrees:\n\nto_celsius <- function(temp = 1) {\n  (temp - 32) * 5/9\n}\n\nYou can use to_celsius() as any other function in R. Say you want to know how many Celsius degrees are 95 Fahrenheit degrees:\n\nto_celsius(95)\n\n[1] 35\n\n\nTo make things more interesting, let’s create another function that not only computes the temperature conversion but also prints a more informative message, something like: 95 Fahrenheit degrees = 35 Celsius degrees.\nWe’ll name this function fahrenheit2celsius():\n\nfahrenheit2celsius <- function(temp = 1) {\n  celsius <- to_celsius(temp)\n  sprintf('%.2f Fahrenheit degrees = %.2f Celsius degrees', temp, celsius)\n}\n\nNotice that fahrenheit2celsius() makes use of to_celsius() to compute the Celsius degrees. And then sprintf() is used with the options %.2f to display the temperatures with two decimal digits. Try it out:\n\nfahrenheit2celsius(95)\n\n[1] \"95.00 Fahrenheit degrees = 35.00 Celsius degrees\"\n\nfahrenheit2celsius(50)\n\n[1] \"50.00 Fahrenheit degrees = 10.00 Celsius degrees\"\n\n\n\n\n6.1.5 Example: Car Traveled Distance\nOur third example is a little bit more sophisticated. The idea is to construct an object of class \"car\" that contains characteristics like the name of the car, its make, its year, and its fuel consumption in city, highway and combined.\nLet’s consider a Mazda 3 for this example. One possible way to define a \"car\" object is to use a list with the following elements:\n\nmazda3 <- list(\n  name = 'mazda3', # car name\n  make = 'mazda',  # car make\n  year = 2015,     # year model\n  city = 30,       # fuel consumption in city\n  highway = 40,    # fuel consumption in highway\n  combined = 33)   # fuel consumption combined (city-and-hwy)\n\nSo far we have an object mazda3 that is essentially a list. Because we want to create a print() method for objects of class \"car\" we need to assign this class to our mazda3:\n\nclass(mazda3) <- \"car\"\n\nNow that we have our \"car\" object, we can create a print.car() function. In this way, everytime we type mazda3, instead of getting the typical list output, we will get a customized display:\n\nprint.car <- function(x) {\n  cat(\"Car\\n\")\n  cat(sprintf('name: %s\\n', x$name))\n  cat(sprintf('make: %s\\n', x$make))\n  cat(sprintf('year: %s\\n', x$year))\n  invisible(x)\n}\n\nNext time you type mazda3 in your console, R will display these lines:\n\nmazda3\n\nCar\nname: mazda3\nmake: mazda\nyear: 2015\n\n\nIt would be nice to have a function miles() that allows you to calculate the traveled distance for a given amount of gas (in gallons), taking into account the type of fuel consumption (e.g. city, highway, combined):\n\nmiles <- function(car, fuel = 1, mpg = 'city') {\n  stopifnot(class(car) == 'car')\n  switch(mpg,\n         'city' = car$city * fuel,\n         'highway' = car$highway * fuel,\n         'combined' = car$combined * fuel,\n         car$city * fuel)\n}\n\nThe miles() function takes three parameters: car is an object of class \"car\", fuel is the number of gallons, and mpg is the type of fuel consumption ('city', 'highway', 'combined'). The first command checks whether the first parameter is an object of class \"car\". If it is not, then the function will stop the execution raising an error. The second command involves using the function switch() to compute the traveled miles. It switches to the corresponding consumption depending on the provided value of mpg. Note that the very last switch condition is a safety condition in case the user mispecifies mpg.\nLet’s say you want to know how many miles the mazda3 could travel with 4 gallons of gas depending on the different types of consumption:\n\nmiles(mazda3, fuel = 4, 'city')\n\n[1] 120\n\nmiles(mazda3, fuel = 4, 'highway')\n\n[1] 160\n\nmiles(mazda3, fuel = 4, 'combined')\n\n[1] 132\n\n\nAgain, to make things more user friendly, we are going to create a function get_distance() that prints a more informative message about the traveled distance:\n\nget_distance <- function(car, fuel = 1, mpg = 'city') {\n  distance <- miles(car, fuel = fuel, mpg = mpg) \n  cat(sprintf('A %s can travel %s miles\\n',\n              car$name, distance))\n  cat(sprintf('with %s gallons of gas\\n', fuel))\n  cat(sprintf('using %s consumption', mpg))\n}\n\nAnd this is how the output when calling get_distance looks like:\n\nget_distance(mazda3, 4, 'city')\n\nA mazda3 can travel 120 miles\nwith 4 gallons of gas\nusing city consumption\n\n\n\n\n6.1.6 Example: Coffee Prices\nConsider some coffee drinks and their prices. We’ll put this information in a vector like this:\n\nprices <- c(\n  'americano' = 2, \n  'latte' = 2.75, \n  'mocha' = 3.45, \n  'capuccino' = 3.25)\n\nWhat type of vector is prices? Is it a character vector? Is it numeric vector? Or is it some sort of vector with mix-data? We have seen that vectors are atomic structures, meaning that all their elements must be of the same class. So prices is definitely not a vector with mix-data. From the code chunk we can observe that each element of the vector is formed by a string, followed by the = sign, followed by some number. This way of defining a vector is not very common in R but it is perfectly valid. Each string represents the name of an element, while the numbers are the actual elements. Therefore prices is in reality a numeric vector. You can confirm this by looking at the mode (or data type):\n\nmode(prices)\n\n[1] \"numeric\"\n\n\nLet’s say you want to list the names of the coffees and their prices. If you just simply try to print() the prices, the output will be the entire vector prices:\n\nprint(prices)\n\namericano     latte     mocha capuccino \n     2.00      2.75      3.45      3.25 \n\n\nAlternatively, you can use a for loop to print() each individual element of the vector prices, but again the output is displayed in an awkward fashion:\n\nfor (p in seq_along(prices)) {\n  print(prices[p])\n}\n\namericano \n        2 \nlatte \n 2.75 \nmocha \n 3.45 \ncapuccino \n     3.25 \n\n\nTo list the names of the coffees and their prices, it would be nicer to use a combination of paste0() and print(). In addition, you can be more descriptive adding some auxiliary text such that the output prints something like: “americano has a price of $2”.\n\nfor (p in seq_along(prices)) {\n  print(paste0(names(prices)[p], ' has price of $', prices[p]))\n}\n\n[1] \"americano has price of $2\"\n[1] \"latte has price of $2.75\"\n[1] \"mocha has price of $3.45\"\n[1] \"capuccino has price of $3.25\"\n\n\nAnother possible solution consists of combining print() and sprintf():\n\nfor (p in seq_along(prices)) {\n  print(sprintf('%s has price of $%s', names(prices)[p], prices[p]))\n}\n\n[1] \"americano has price of $2\"\n[1] \"latte has price of $2.75\"\n[1] \"mocha has price of $3.45\"\n[1] \"capuccino has price of $3.25\"\n\n\nOne limitation of quote() is that it won’t work inside a for loop:\n\nfor (p in seq_along(prices)) {\n  noquote(sprintf('%s has price of $%s', names(prices)[p], prices[p]))\n}\n\nIf what you want is to print the output wihtout quotes, then you need to use cat(); just make sure to add a newline character \"\\n\":\n\nfor (p in seq_along(prices)) {\n  cat(sprintf('%s has price of $%s\\n', names(prices)[p], prices[p]))\n}\n\namericano has price of $2\nlatte has price of $2.75\nmocha has price of $3.45\ncapuccino has price of $3.25\n\n\n\n\n6.1.7 Converting objects to strings with toString()\nThe function toString() allows us to convert an R object to a character string. This function can be used as a helper for format() to produce a single character string from several obejcts inside a vector. The result will be a character vector of length 1 with elements separated by commas:\n\n# default usage\ntoString(17.04)\n\n[1] \"17.04\"\n\n# combining two objects\ntoString(c(17.04, 1978))\n\n[1] \"17.04, 1978\"\n\n# combining several objects\ntoString(c(\"Bonjour\", 123, TRUE, NA, log(exp(1))))\n\n[1] \"Bonjour, 123, TRUE, NA, 1\"\n\n\nOne of the nice features about toString() is that you can specify its argument width to fix a maximum field width.\n\n# use of 'width'\ntoString(c(\"one\", \"two\", \"3333333333\"), width = 8)\n\n[1] \"one,....\"\n\n# use of 'width'\ntoString(c(\"one\", \"two\", \"3333333333\"), width = 12)\n\n[1] \"one, two....\"\n\n\n\n\n6.1.8 Comparing printing methods\nEven though R has just a small collection of functions for printing and formatting strings, we can use them to get a wide variety of outputs. The choice of function (and its arguments) will depend on what we want to print, how we want to print it, and where we want to print it. Sometimes the answer of which function to use is straightforward. Sometimes however, we would need to experiment and compare different ways until we find the most adequate method. To finish this section let’s consider a simple example with a numeric vector with 5 elements:\n\n# printing method \nprint(1:5)\n\n[1] 1 2 3 4 5\n\n# convert to character\nas.character(1:5)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n# concatenation\ncat(1:5, sep=\"-\")\n\n1-2-3-4-5\n\n# default pasting\npaste(1:5)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n# paste with collapsing\npaste(1:5, collapse = \"\")\n\n[1] \"12345\"\n\n# convert to a single string\ntoString(1:5)\n\n[1] \"1, 2, 3, 4, 5\"\n\n# unquoted output\nnoquote(as.character(1:5))\n\n[1] 1 2 3 4 5"
  },
  {
    "objectID": "07-input-output.html",
    "href": "07-input-output.html",
    "title": "7  Input and Output",
    "section": "",
    "text": "Some times you need to export results to a file. Typically this happens when you want to export a data table to a text file. R provides the functions write.table() and write.csv() for these purposes. These functions let you send a matrix or a data frame to a text file that will have a tabular format (i.e. rows and columns).\n\n\nYou can use cat() to concatenate and print information to a file.\nTo show you how to use cat() let’s illustrate a simple example using the data frame mtcars that comes in R.\n\n# summary statistics of unemp\nmin(mtcars$mpg)\nmax(mtcars$mpg)\nmedian(mtcars$mpg)\nmean(mtcars$mpg)\nsd(mtcars$mpg)\n\nThe goal is to generate a file mpg-statistics.txt with the following contents:\nMiles per Gallon Statistics\n\nMinimum: 10.40\nMaximum: 33.90\nMedian : 19.20\nMean   : 20.09 \nStd Dev: 6.02\nHere is one way to do it. First, let’s assign the statistics to different objects:\n\n# summary statistics of mpg\nmpg_min <- min(mtcars$mpg)\nmpg_max <- max(mtcars$mpg)\nmpg_med <- median(mtcars$mpg)\nmpg_avg <- mean(mtcars$mpg)\nmpg_sd <- sd(mtcars$mpg)\n\nAfter creating the objects containing the summary statistics, the next step is to export them to the text file mpg-statistics.txt via cat(). Assuming that the output file is in your working directory, here’s how you can send the set of strings to the text file:\n\n# name of output file\noutfile <- \"mpg-statistics.txt\"\n\n# first line of the file\ncat(\"Miles per Gallon Statistics\\n\\n\", file = outfile)\n\n# subsequent lines appended to the output file\ncat(\"Minimum:\", mpg_min, \"\\n\", file = outfile, append = TRUE)\ncat(\"Maximum:\", mpg_max, \"\\n\", file = outfile, append = TRUE)\ncat(\"Median :\", mpg_med, \"\\n\", file = outfile, append = TRUE)\ncat(\"Mean   :\", mpg_avg, \"\\n\", file = outfile, append = TRUE)\ncat(\"Std Dev:\", mpg_sd, \"\\n\", file = outfile, append = TRUE)\n\nThe first line exported to mpg-statistics.txt is a string with the title \"Miles per Gallon Statistics\\n\\n\". Observe that we are using two new line characters \"\\n\\n\" to add some space between the title and the statistics. The rest of calls to cat() use the argument append = TRUE to concatenate the specified strings to the end of the text file without overriding the existing lines.\nIf you run the code of this example and look at the contents of mpg-statistics.txt, you will see the following output:\nMiles per Gallon Statistics\n\nMinimum: 10.4 \nMaximum: 33.9 \nMedian : 19.2 \nMean   : 20.09062 \nStd Dev: 6.026948 \nAs you can tell, the displayed values have a different number of decimal digits. If you just want to keep two decimal digits, you can use sprintf() and choose the format \"%0.2f\". Let’s re-export the lines:\n\ncat(\"Miles per Gallon Statistics\\n\\n\", file = outfile)\ncat(sprintf('Minimum: %0.2f', mpg_min), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf('Maximum: %0.2f', mpg_max), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf('Median : %0.2f', mpg_med), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf('Mean   : %0.2f', mpg_avg), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf('Std Dev: %0.2f', mpg_sd), \"\\n\", file = outfile, append = TRUE)\n\nNow the content of mpg-statistics.txt should look like this:\nMiles per Gallon Statistics\n\nMinimum: 10.40 \nMaximum: 33.90 \nMedian : 19.20 \nMean   : 20.09 \nStd Dev: 6.03 \nHere is an exercise for you: How would you avoid writing that many calls to cat()?\n\n\n\nAnother interesting function is sink(). This function is very useful when you want to export R output as is displayed in the R console. For example, consider the output from summary()\n\nsummary(mtcars)\n\nYou could assign the output of summary(mtcars) to an object and then try writeLines() to export the results to a file mtcars-summary.txt, but you won’t keep the same format of R:\n\nmtcars_summary <- summary(mtcars)\nwriteLines(mtcars_summary, con = \"mtcars-summary.txt\")\n\nTo be able to keep the same output display of R, you must use sink(). This function will divert R output to the specified file:\n\nsink(file = \"mtcars-statistics.txt\")\nsummary(mtcars)\nsink()\n\nYour turn: Use sink() to send the output from running a linear regression of mpg on disp with the function lm(). Also export the results from using summary() on the regression object. And/or try running a t-test between mpg and disp with t.test()."
  },
  {
    "objectID": "07-input-output.html#exporting-tables",
    "href": "07-input-output.html#exporting-tables",
    "title": "7  Input and Output",
    "section": "7.2 Exporting Tables",
    "text": "7.2 Exporting Tables\nAnother interesting tool to export tables in LaTeX or HTML formats is provided by the R package \"xtable\" and its main function xtable().\n\nlibrary(xtable)\n\n# linear regression\nreg <- lm(mpg ~ disp, data = mtcars)\n\n# create xtable and export it\nreg_table <- xtable(reg)\n\nThe object reg_table is an object of class \"xtable\". What you do with this type of objects is print() them to a file.\nTo print reg_table in latex format to a .tex file:\n\nprint(reg_table, type = \"latex\", file = \"reg-table.tex\")\n\nTo print reg_table in html format to an .html file:\n\nprint(reg_table, type = \"html\", file = \"reg-table.html\")"
  },
  {
    "objectID": "08-regex-intro.html",
    "href": "08-regex-intro.html",
    "title": "8  Getting Started with Regular Expressions",
    "section": "",
    "text": "So far you have learned some basic and intermediate functions for handling and working with text in R. These are very useful functions and they allow you to do many interesting things. However, if you truly want to unleash the power of strings manipulation, you need to take things to the next level and learn about regular expressions.\nIn this chapter, we use functions from the package \"stringr\""
  },
  {
    "objectID": "08-regex-intro.html#what-are-regular-expressions",
    "href": "08-regex-intro.html#what-are-regular-expressions",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.1 What are Regular Expressions?",
    "text": "8.1 What are Regular Expressions?\nThe name “Regular Expression” does not say much. However, regular expressions are all about text. Think about how much text is all around you in our modern digital world: email, text messages, news articles, blogs, computer code, contacts in your address book—all these things are text. Regular expressions are a tool that allows us to work with these text by describing text patterns.\nA regular expression is a special text string for describing a certain amount of text. This “certain amount of text” receives the formal name of pattern. In other words, a regular expression is a set of symbols that describes a text pattern. More formally we say that a regular expression is a pattern that describes a set of strings. In addition to this first meaning, the term regular expression can also be used in a slightly different but related way: as the formal language of these symbols that needs to be interpreted by a regular expression processor. Because the term “regular expression” is rather long, most people use the word regex as a shortcut term. And you will even find the plural regexes.\nIt is also worth noting what regular expressions are not. They’re not a programming language. They may look like some sort of programming language because they are a formal language with a defined set of rules that gets a computer to do what we want it to do. However, there are no variables in regex and you can’t do computations like adding 1 + 1.\n\n8.1.1 What are Regular Expressions used for?\nWe use regular expressions to work with text. Some of its common uses involve testing if a phone number has the correct number of digits, if a date follows a specifc format (e.g. mm/dd/yy), if an email address is in a valid format, or if a password has numbers and special characters. You could also use regular expressions to search a document for gray spelt either as “gray” or “grey”. You could search a document and replace all occurrences of “Will”, “Bill”, or “W.” with William. Or you could count the number of times in a document that the word “analysis” is immediately preceded by the words “data”, “computer” or “statistical” only in those cases. You could use it to convert a comma-delimited file into a tab-delimited file or to find duplicate words in a text.\nIn each of these cases, you are going to use a regular expression to write up a description of what you are looking for using symbols. In the case of a phone number, that pattern might be three digits followed by a dash, followed by three digits and another dash, followed by four digits. Once you have defined a pattern then the regex processor will use our description to return matching results, or in the case of the test, to return true or false for whether or not it matched.\n\n\n8.1.2 A word of caution about regex\nIf you have never used regular expressions before, their syntax may seem a bit scary and cryptic. You will see strings formed by a bunch of letters, digits, and other punctuation symbols combined in seemingly nonsensical ways. As with any other topic that has to do with programming and data analysis, learning the principles of regex and becoming fluent in defining regex patterns takes time and requires a lot of practice. The more you use them, the better you will become at defining more complex patterns and getting the most out of them.\nRegular Expressions is a wide topic and there are books entirely dedicated to this subject. The material offered in this book is not extensive and there are many subtopics that I don’t cover here. Despite the initial barriers that you may encounter when entering the regex world, the pain and frustration of learning this tool will payoff in your data science career.\n\n\n8.1.3 About Regular Expressions in R\nTools for working with regular expressions can be found in virtually all scripting languages (e.g. Perl, Python, Java, Ruby, etc). R has some functions for working with regular expressions but it does not provide the wide range of capabilities that other scripting languages do. Nevertheless, they can take you very far with some workarounds (and a bit of patience).\nAlthough I am assuming that you are new to regex, I won’t cover everything there is to know about regular expressions. Instead, I will focus on how R works with regular expressions, as well as the R syntax that you will have to use for regex operations.\nOne of the best tools you must have in your toolkit is the R package \"stringr\" (by Hadley Wickham). It provides functions that have similar behavior to those of the base distribution in R. But it also provides many more facilities for working with regular expressions.\nTo know more about regular expressions in general, you can find some useful infor- mation in the following resources:\n\nRegex wikipedia: For those readers who have no experience with regular expressions, a good place to start is by checking the wikipedia entrance.\n\nhttp://en.wikipedia.org/wiki/Regular_expression\n\nRegular-Expressions.info website (by Jan Goyvaerts): An excelent website full of information about regular expressions. It contains many different topics, resources, lots of examples, and tutorials, covered at both beginner and advanced levels.\n\nhttp://www.regular-expressions.info\n\nMastering Regular Expressions (by Jeffrey Friedl): I wasn’t sure whether to include this reference but I think it deserves to be considered as well. This is perhaps the authoritative book on regular expressions. The only issue is that it is a book better adressed for readers already experienced with regex.\n\nhttp://regex.info/book.html"
  },
  {
    "objectID": "08-regex-intro.html#regex-basics",
    "href": "08-regex-intro.html#regex-basics",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.2 Regex Basics",
    "text": "8.2 Regex Basics\nThe main purpose of working with regular expressions is to describe patterns that are used to match against text strings. Simply put, working with regular expressions is nothing more than pattern matching. The result of a match is either successful or not.\nThe simplest version of pattern matching is to search for one occurrence (or all occurrences) of some specific characters in a string. For example, we might want to search for the word \"programming\" in a large text document, or we might want to search for all occurrences of the string \"apply\" in a series of files containing R scripts.\nTypically, regular expression patterns consist of a combination of alphanumeric characters as well as special characters. A regex pattern can be as simple as a single character, or it can be formed by several characters with a more complex structure. In all cases we construct regular expressions much in the same form in which we construct arithmetic expressions, by using various operators to combine smaller expressions."
  },
  {
    "objectID": "08-regex-intro.html#literal-characters",
    "href": "08-regex-intro.html#literal-characters",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.3 Literal Characters",
    "text": "8.3 Literal Characters\nWe’re going to start with the simplest match of all: a literal character. A literal character match is one in which a given character such as the letter \"R\" matches the letter R. This type of match is the most basic type of regular expression operation: just matching plain text.\n\n8.3.1 Matching Literal Characters\nThe following examples are extremely basic but they will help you get a good understanding of regex.\nConsider the following text stored in a character vector this_book:\n\nthis_book <- 'This book is mine'\n\nThe first regular expression we are going to work with is \"book\". This pattern is formed by a letter b, followed by a letter o, followed by another letter o, followed by a letter k. As you may guess, this pattern matches the word book in the character vector this_book. To have a visual representation of the actual pattern that is matched, you should use the function str_view() from the package \"stringr\" (you may need to upgrade to a recent version of RStudio):\n\nstr_view(this_book, 'book')\n\nAs you can tell, the pattern \"book\" doesn’t match the entire content in the vector this_book; it just matches those four letters.\nIt may seem really simple but there are a couple of details to be highlighted. The first is that regex searches are case sensitive by default. This means that the pattern \"Book\" would not match book in this_book.\n\nstr_view(\"This Book is mine.\", 'book')\n\nYou can change the matching task so that it is case insensitive but we will talk about it later.\nLet’s add more text to this_book:\n\nthis_book <- 'This book is mine. I wrote this book with bookdown.'\n\nLet’s use str_view() to see what pieces of text are matched in this_book with the pattern \"book\":\n\nstr_view(this_book, \"book\")\n\nAs you can tell, only the first occurrence of book was matched. This is a common behavior of regular expressions in which they return a match as fast possible. You can think of this behavior as the “eager principle”, that is, regular expressions are eager and they will give preference to an early match. This is a minor but important detail and we will come back to this behavior of regular expressions.\nAll the letters and digits in the English alphabet are considered literal characters. They are called literal because they match themselves.\n\nstr_view <- c(\"I had 3 quesadillas for lunch\", \"3\")\n\nHere is another example:\n\ntransport <- c(\"car\", \"bike\", \"boat\", \"airplane\")\n\nThe first pattern to test is the letter \"a\":\n\nstr_view(transport, \"a\")\n\nWhen you execute the previous command, you should be able to see that the letter \"a\" is highlighted in the words car, boat and airplane."
  },
  {
    "objectID": "08-regex-intro.html#r-functions-for-regular-expressions",
    "href": "08-regex-intro.html#r-functions-for-regular-expressions",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.4 R Functions for Regular Expressions",
    "text": "8.4 R Functions for Regular Expressions\nIn order to move on with the discussion of regular expressions, we need to talk about some of the functions available in R for regex.\n\n8.4.1 Regex Functions in \"base\" Package\nR contains a set of functions in the \"base\" package that we can use to find pattern matches. The following table lists these functions with a brief description:\n\n\n\n\n\n\n\n\nFunction\nPurpose\nCharacteristic\n\n\n\n\ngrep()\nfinding regex matches\nwhich elements are matched (index or value)\n\n\ngrepl()\nfinding regex matches\nwhich elements are matched (TRUE,FALSE)\n\n\nregexpr()\nfinding regex matches\npositions of the first match\n\n\ngregexpr()\nfinding regex matches\npositions of all matches\n\n\nregexec()\nfinding regex matches\nhybrid of regexpr() and gregexpr()\n\n\nsub()\nreplacing regex matches\nonly first match is replaced\n\n\ngsub()\nreplacing regex matches\nall matches are replaced\n\n\nstrsplit()\nsplitting regex matches\nsplit vector according to matches\n\n\n\nThe first five functions listed in the previous table are used for finding pattern matches in character vectors. The goal is the same for all these functions: finding a match. The difference between them is in the format of the output. The next two functions—sub() and gsub()— are used for substitution: looking for matches with the purpose of replacing them. The last function, strsplit(), is used to split elements of a character vector into substrings according to regex matches.\nBasically, all regex functions require two main arguments: a pattern (i.e. regular expression), and a text to match. Each function has other additional arguments but the main ones are a pattern and some text. In particular, the pattern is basically a character string containing a regular expression to be matched in the given text.\nYou can check the documentation of all the grep()-like functions by typing help(grep) (or alternatively ?grep).\n\n# help documentation for main regex functions\nhelp(grep)\n\n\n\n8.4.2 Regex Functions in Package \"stringr\"\nThe R package \"stringr\" also provides several functions for regex operations (see table below). More specifically, \"stringr\" provides pattern matching functions to detect, locate, extract, match, replace and split strings.\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nstr_detect()\nDetect the presence or absence of a pattern in a string\n\n\nstr_extract()\nExtract first piece of a string that matches a pattern\n\n\nstr_extract_all()\nExtract all pieces of a string that match a pattern\n\n\nstr_match()\nExtract first matched group from a string\n\n\nstr_match_all()\nExtract all matched groups from a string\n\n\nstr_locate()\nLocate the position of the first occurence of a pattern in a string\n\n\nstr_locate_all()\nLocate the position of all occurences of a pattern in a string\n\n\nstr_replace()\nReplace first occurrence of a matched pattern in a string\n\n\nstr_replace_all()\nReplace all occurrences of a matched pattern in a string\n\n\nstr_split()\nSplit up a string into a variable number of pieces\n\n\nstr_split_fixed()\nSplit up a string into a fixed number of pieces\n\n\n\nOne of the important things to keep in mind is that all pattern matching functions in \"stringr\" have the following general form:\nstr_function(string, pattern)\nThe main two arguments are: a string vector to be processed , and a single pattern (i.e. regular expression) to match. Moreover, all the function names begin with the prefix str_, followed by the name of the action to be performed. For example, to locate the position of the first occurence, we should use str_locate(); to locate the positions of all matches we should use str_locate all().\n\n\n8.4.3 Matching Literal Characters With \"stringr\" Functions\nHaving introduced the regex functions available in \"stringr\", let’s continue describing how to omatch literal characters. We had defined a string this_book\n\nthis_book <- 'This book is mine. I wrote this book with bookdown.'\n\nWe can use the function str_detect() to look for the pattern \"book\"\n\nstr_detect(string = this_book, pattern = \"book\")\n\n[1] TRUE\n\n\nIf there is a match, then {str_detect() returns TRUE. Conversely, if there is no match, str_detect() will return FALSE\n\nstr_detect(string = this_book, pattern = 'tablet')\n\n[1] FALSE\n\n\nAll the letters and digits in the English alphabet are considered literal characters. They are called literal because they match themselves.\n\nstr_detect <- c(string = \"I had 3 quesadillas for lunch\", pattern = \"3\")\n\nHere is another example:\n\ntransport <- c(\"car\", \"bike\", \"boat\", \"airplane\")\n\nThe first pattern to test is the letter \"a\":\n\nstr_view(string = transport, pattern = \"a\")\n\nWhen you execute the previous command, you should be able to see that the letter \"a\" is highlighted in the words car, boat and airplane."
  },
  {
    "objectID": "08-regex-intro.html#metacharacters",
    "href": "08-regex-intro.html#metacharacters",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.5 Metacharacters",
    "text": "8.5 Metacharacters\nThe next topic that you should learn about regular expressions has to do with metacharacters. As you just learned, the most basic type of regular expressions are the literal characters which are characters that match themselves. However, not all characters match themselves. Any character that is not a literal character is a metacharacter.\n\n8.5.1 About Metacharacters\nMetacharacter are characters that have a special meaning and they allow you to transform literal characters in very interesting ways. Sometimes they act like mathematical operators: transforming literal characters into powerful expressions.\nBelow is the list of metacharacters in Extended Regular Expressions (EREs):\n.   \\   |   (   )   [   ]   {   }   $   -    ^   *   +   ?\n\nthe dot .\nthe backslash \\\nthe bar |\nleft or opening parenthesis (\nright or closing parenthesis )\nleft or opening bracket [\nright or closing bracket ]\nleft or opening brace {\nright or closing brace }\nthe dollar sign $\nthe dash, hyphen or minus sign -\nthe caret or hat ^\nthe star or asterisk *\nthe plus sign +\nthe question mark ?\n\nFor example, the pattern \"money\\$\" does not match “money$”. Likewise, the pattern \"what?\" does not match “what?”. Except for a few cases, metacharacters have a special meaning and purporse when working with regular expressions.\nWe’re going to be working with these characters throughout the rest of the book. Simply put, everything else that you need to know about regular expressions besides literal characters is how these metacharacters work. The good news is that there are only a few metacharacters to learn. The bad news is that some metacharacters can have more than one meaning. And learning those meanings definitely takes time and requires hours of practice. The meaning of the metacharacters greatly depend on the context in which you use them, how you use them, and where you use them. If it wasn’t enough complication, it is also the metacharacters that have variation between the different regex engines."
  },
  {
    "objectID": "08-regex-intro.html#the-wildcard-metacharacter",
    "href": "08-regex-intro.html#the-wildcard-metacharacter",
    "title": "8  Getting Started with Regular Expressions",
    "section": "8.6 The Wildcard Metacharacter",
    "text": "8.6 The Wildcard Metacharacter\nThe first metacharacter you should learn about is the dot or period \".\", better known as the wildcard metacharacter.\nLike in many card games where one of the cards in the deck is wild and can be used to replace other types of cards, there is also a wild character in regex that has the same purpose—hence its name.\nThis metacharacter is used to match ANY character except for a new line.\nFor example, consider the pattern \"p.n\", that is, p wildcard n. This pattern will match pan, pen, and pin, but it will not match prun or plan. The dot only matches one single character.\n\npns <- c('pan', 'pen', 'pin', 'plan', 'prun', 'p n', 'p\\nn')\n\nstr_detect(string = pns, pattern = 'p.n')\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE\n\n\nObserve that \"p.n\" even matches the blank space, and the new line character \"\\n\". The reason why it does not match plan is because the third character is an a and not an n.\nLet’s see another example using the vector c(\"not\", \"note\", \"knot\", \"nut\") and the pattern \"n.t\"\n\nnot <- c(\"not\", \"note\", \"knot\", \"nut\")\n\nstr_view(not, \"n.t\")\n\nthe pattern \"n.t\" matches not in the first three elements, and nut in the last element.\nIf you specify a pattern \"no.\", then just the first three elements in not will be matched.\n\nstr_view(not, \"no.\")\n\nAnd if you define a pattern \"kn.\", then only the third element is matched.\n\nstr_view(not, \"kn.\")\n\nThe wild metacharacter is probably the most used metacharacter, and it is also the most abused one, being the source of many mistakes. Here is a basic example with the regular expression formed by \"5.00\". If you think that this pattern will match five with two decimal places after it, you will be surprised to find out that it not only matches 5.00 but also 5100 and 5-00. Why? Because \".\" is the metacharacter that matches absolutely anything. You will learn how to fix this mistake in the next section, but it illustrates an important fact about regular expressions: the challenge consists of matching what you want, but also in matching only what you want. You don’t want to specify a pattern that is overly permissive. You want to find the thing you’re looking for, but only that thing.\nAs an experiment, try writing a pattern that will match silver, sliver, and slider. See if you can use wildcards to come up with a regular expression that will match all three of those.\n\nsil <- c('silver', 'sliver', 'slider')\n\n# your pattern\npat <- ...\n\n# test it\nstr_detect(string = sil, pattern = pat)\n\n\n8.6.1 Escaping metacharacters\nWhat if you just want to match the character dot? For example, say you have the following vector:\n\nfives <- c(\"5.00\", \"5100\", \"5-00\", \"5 00\")\n\nIf you try the pattern \"5.00\", it will match all of the elements in fives.\n\nstr_view(fives, \"5.00\")\n\nTo actually match the dot character, what you need to do is escape the metacharacter. In most languages, the way to escape a metacharacter is by adding a backslash character in front of the metacharacter: \"\\.\". When you use a backslash in front of a metacharacter you are “escaping” the character, this means that the character no longer has a special meaning, and it will match itself.\nHowever, R is a bit different. Instead of using a backslash you have to use two backslashes: \"5\\\\.00\". This is because the backslash \"\\\", which is another metacharacter, has a special meaning in R. Therefore, to match just the element 5.00 in fives in R, you do it like so:\n\nstr_view(fives, \"5\\\\.00\")\n\nThe following list shows the general regex metacharacters and how to escape them in R:\n\n\n\nMetachacter\nLiteral meaning\nEscape in R\n\n\n\n\n.\nthe period or dot\n\"\\\\.\"\n\n\n$\nthe dollar sign\n\"\\\\$\"\n\n\n*\nthe asterisk or star\n\"\\\\*\"\n\n\n+\nthe plus sign\n\"\\\\+\"\n\n\n?\nthe question mark\n\"\\\\?\"\n\n\n|\nthe vertical bar\n\"\\\\|\"\n\n\n\\\nthe backslah\n\"\\\\\\\\\"\n\n\n^\nthe caret or hat\n\"\\\\^\"\n\n\n[\nthe opening bracket\n\"\\\\[\"\n\n\n]\nthe closing bracket\n\"\\\\]\"\n\n\n{\nthe opening brace\n\"\\\\{\"\n\n\n}\nthe closing brace\n\"\\\\}\"\n\n\n(\nthe opening parenthesis\n\"\\\\(\"\n\n\n)\nthe closing parenthesis\n\"\\\\)\"\n\n\n\nHere are some silly examples that show how to escape metacharacters in R in order to be replaced with an empty \"\":\n\n# dollar\nstr_replace(\"$Peace-Love\", \"\\\\$\", \"\")\n\n[1] \"Peace-Love\"\n\n# dot\nstr_replace(\"Peace.Love\", \"\\\\.\", \"\")\n\n[1] \"PeaceLove\"\n\n# plus\nstr_replace(\"Peace+Love\", \"\\\\+\", \"\")\n\n[1] \"PeaceLove\"\n\n# caret\nstr_replace(\"Peace^Love\", \"\\\\^\", \"\")\n\n[1] \"PeaceLove\"\n\n# vertical bar\nstr_replace(\"Peace|Love\", \"\\\\|\", \"\")\n\n[1] \"PeaceLove\"\n\n# opening round bracket\nstr_replace(\"Peace(Love)\", \"\\\\(\", \"\")\n\n[1] \"PeaceLove)\"\n\n# closing round bracket\nstr_replace(\"Peace(Love)\", \"\\\\)\", \"\")\n\n[1] \"Peace(Love\"\n\n# opening square bracket\nstr_replace(\"Peace[Love]\", \"\\\\[\", \"\")\n\n[1] \"PeaceLove]\"\n\n# closing square bracket\nstr_replace(\"Peace[Love]\", \"\\\\]\", \"\")\n\n[1] \"Peace[Love\"\n\n# opening curly bracket\nstr_replace(\"Peace{Love}\", \"\\\\{\", \"\")\n\n[1] \"PeaceLove}\"\n\n# closing curly bracket\nstr_replace(\"Peace{Love}\", \"\\\\}\", \"\")\n\n[1] \"Peace{Love\"\n\n# double backslash\nstr_replace(\"Peace\\\\Love\", \"\\\\\\\\\", \"\")\n\n[1] \"PeaceLove\""
  },
  {
    "objectID": "09-regex-charsets.html",
    "href": "09-regex-charsets.html",
    "title": "9  Character Sets",
    "section": "",
    "text": "In this chapter we will talk about character sets. You will learn about a couple of more metacharacters, the opening and closing brackets [ ], that will help you define a character set.\nThese square brackets indicate a character set which will match any one of the various characters that are inside the set. Keep in mind that a character set will match only one character. The order of the characters inside the set does not matter; what matter is just the presence of the characters inside the brackets. So for example if you have a set defined by \"[AEIOU]\", that will match any one upper case vowel."
  },
  {
    "objectID": "09-regex-charsets.html#defining-character-sets",
    "href": "09-regex-charsets.html#defining-character-sets",
    "title": "9  Character Sets",
    "section": "9.1 Defining character sets",
    "text": "9.1 Defining character sets\nLet’s bring back the vector pns\n\npns <- c('pan', 'pen', 'pin', 'pon', 'pun')\npns\n\n[1] \"pan\" \"pen\" \"pin\" \"pon\" \"pun\"\n\n\nConsider the following pattern that includes a character set: \"p[aeiou]n\". As you can tell, this pattern is formed by the character p, folled by the set [aeiou], followed by the character n. What does this pattern match? Let’s find out with str_view()\n\nstr_view(pns, \"p[aeiou]n\")\n\nThe set \"p[aeiou]n\" matches all elements in pns.\nFor comparison purposes, let’s create another vector pnx\n\npnx <- c('pan', 'pen', 'pin', 'p0n', 'p.n', 'p1n', 'paun')\npnx\n\n[1] \"pan\"  \"pen\"  \"pin\"  \"p0n\"  \"p.n\"  \"p1n\"  \"paun\"\n\n\nAnd let’s test again the pattern \"p[aeiou]n\" to see what elements are matched\n\nstr_view(pnx, \"p[aeiou]n\")\n\nThis time only the first three elements in pnx are matched. Notice also that paun is not matched. This is because the character set matches only one character, either a or u but not au.\nIf you are interested in matching all capital letters in English, you can define a set formed as:\n[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\nLikewise, you can define a set with only lower case letters in English:\n[abcdefghijklmnopqrstuvwxyz]\nIf you are interested in matching any digit, you can also specify a character set like this:\n[0123456789]"
  },
  {
    "objectID": "09-regex-charsets.html#character-ranges",
    "href": "09-regex-charsets.html#character-ranges",
    "title": "9  Character Sets",
    "section": "9.2 Character ranges",
    "text": "9.2 Character ranges\nThe previous examples that show character sets containing all the capital letters or all lower case letters are very convenient but require a lot of typing. Character ranges are going to help you solve that problem, by giving you a convenient shortcut based on the dash metacharacter \"-\" to indicate a range of characters. A character range consists of a character set with two characters separated by a dash or minus \"-\" sign.\nLet’s see how you can reexpress the examples in the previous section as character ranges. The set of all digits can be expressed as a character range using the following pattern:\n[0-9]\nLikewise, the set of all lower case letters abcd…xyz is compactly represented with the character range:\n[a-z]\nAnd the character set of all upper case letters ABD…XYZ is formed by\n[A-Z]\nNote that the dash is only a metacharacter when it is inside a character set; outside the character set it is just a literal dash.\nSo how do you use character range? To illustrate the concept of character ranges let’s create a basic vector with some simple strings, and see what the different ranges match:\n\nbasic <- c('1', 'a', 'A', '&', '-', '^')\n\nFirst, we use the range [0-9] to match any single digit\n\n# digits\nstr_view(basic, '[0-9]')\n\nThen we use the range of lower case letters [a-z]\n\n# lower case letters\nstr_view(basic, '[a-z]')\n\nAnd finally the range of upper case letters [A-Z]\n\n# upper case letters\nstr_view(basic, '[A-Z]')\n\nNow consider the following vector triplets:\n\ntriplets <- c('123', 'abc', 'ABC', ':-)')\n\nYou can use a series of character ranges to match various occurrences of a certain type of character. For example, to match three consecutive digits you can define a pattern \"[0-9][0-9][0-9]\"; to match three consecutive lower case letters you can use the pattern \"[a-z][a-z][a-z]\"; and the same idea applies to a pattern that matches three consecutive upper case letters \"[A-Z][A-Z][A-Z]\".\n\nstr_view(triplets, '[0-9][0-9][0-9]')\n\nstr_view(triplets, '[A-Z][A-Z][A-Z]')\n\nObserve that the element \":-)\" is not matched by any of the character ranges that we have seen so far.\nCharacter ranges can be defined in multiple ways. For example, the range \"[1-3]\" indicates any one digit 1, 2, or 3. Another range may be defined as \"[5-9]\" comprising any one digit 5, 6, 7, 8 or 9. The same idea applies to letters. You can define shorter ranges other than \"[a-z]\". One example is \"[a-d]\" which consists of any one letter a, b, c, and d.\n\n\n\nPattern\nDescription\n\n\n\n\n[aeiou]\nmatch any one lower case vowel\n\n\n[AEIOU]\nmatch any one upper case vowel\n\n\n[0123456789]\nmatch any digit\n\n\n[0-9]\nmatch any digit (same as previous class)\n\n\n[a-z]\nmatch any lower case ASCII letter\n\n\n[A-Z]\nmatch any upper case ASCII letter\n\n\n[a-zA-Z0-9]\nmatch any of the above classes\n\n\n[^aeiou]\nmatch anything other than a lowercase vowel\n\n\n[^0-9]\nmatch anything other than a digit"
  },
  {
    "objectID": "09-regex-charsets.html#negative-character-sets",
    "href": "09-regex-charsets.html#negative-character-sets",
    "title": "9  Character Sets",
    "section": "9.3 Negative Character Sets",
    "text": "9.3 Negative Character Sets\nA common situation when working with regular expressions consists of matching characters that are NOT part of a certain set. This type of matching can be done using a negative character set: by matching any one character that is not in the set. To define this type of sets you are going to use the metacharacter caret \"^\". If you are using a QWERTY keyboard, the caret symbol should be located over the key with the number 6.\nThe caret \"^\" is one of those metacharacters that have more than one meaning depending on where it appears in a pattern. If you use a caret in the first position inside a character set, e.g. [^aeiou], it means negation. In other words, the caret in [^aeiou] means “not any one of lower case vowels.”\nLet’s use the basic vector previously defined:\n\nbasic <- c('1', 'a', 'A', '&', '-', '^')\nbasic\n\n[1] \"1\" \"a\" \"A\" \"&\" \"-\" \"^\"\n\n\nTo match those elements that are NOT upper case letters, you define a negative character range \"[^A-Z]\":\n\nstr_view(basic, '[^A-Z]')\n\nIt is important that the caret is the first character inside the character set, otherwise the set is not a negative one:\n\nstr_view(basic, '[A-Z^]')\n\nIn the example above, the pattern \"[A-Z^]\" means “any one upper case letter or the caret character.” Which is completely different from the negative set \"[^A-Z]\" that negates any one upper case letter.\nIf you want to match any character except the caret, then you need to use a character set with two carets: \"[^^]\". The first caret works as a negative operator, the second caret is the caret character itself:\n\nstr_view(basic, '[^^]')"
  },
  {
    "objectID": "09-regex-charsets.html#metacharacters-inside-character-sets",
    "href": "09-regex-charsets.html#metacharacters-inside-character-sets",
    "title": "9  Character Sets",
    "section": "9.4 Metacharacters Inside Character Sets",
    "text": "9.4 Metacharacters Inside Character Sets\nNow that you know what character sets are, how to define character ranges, and how to specify negative character sets, we need to talk about what happens when including metacharacters inside character sets.\nExcept for the caret in the first position of the character set, any other metacharacter inside a character set is already escaped. This implies that you do not need to escape them using backslashes.\nTo illustrate the use of metacharacters inside character sets, let’s use the pnx vector:\n\npnx <- c('pan', 'pen', 'pin', 'p0n', 'p.n', 'p1n', 'paun')\npnx\n\nThe character set formed by \"p[ae.io]n\" includes the dot character. Remember that, in general, the period is the wildcard metacharacter and it matches any type of character. However, the period in this example is inside a character set, and because of that, it loses its wildcard behavior.\n\nstr_view(pnx, \"p[ae.io]n\")\n\nAs you can tell, \"p[ae.io]n\" matches pan, pen, pin and p.n, but not p0n or p1n because the dot is the literal dot, not a wildcard character anymore.\nNot all metacharacters become literal characters when they appear inside a character set. The exceptions are the closing bracket ], the dash -, the caret ^, and the backslash \\.\nThe closing bracket ] is used to enclose the character set. Thus, if you want to use a literal right bracket inside a character set you must escape it:\n\"[aei\\\\[ou]\"\nRemember that in R you use double backslash for escaping purposes. This is also why the backslash \\, or double backslash in R, does not become a literal character.\nAnother interesting case has to do with the dash or hyphen - character. As you know, the dash inside a character set is used to define a range of characters: e.g. [0-9], [x-z], and [K-P]. As a general rule, if you want to include a literal dash as part of a range, you should escape it: \"[a-z\\\\-]\".\nLet’s modify the basic vector by adding an opening and ending brackets:\n\nbasic <- c('1', 'a', 'A', '&', '-', '^', '[', ']')\n\nHow do you match each of the characters that have a special meaning inside a character set?\n\n# matching a literal caret\nstr_view(basic, \"[a\\\\^]\")\n\n\n# matching a literal dash\nstr_view(basic, \"[a\\\\-]\")\n\n\n# matching a literal opening bracket\nstr_view(basic, \"[a\\\\[]\")\n\n\n# matching a literal closing bracket\nstr_view(basic, \"[a\\\\]]\")"
  },
  {
    "objectID": "09-regex-charsets.html#character-classes",
    "href": "09-regex-charsets.html#character-classes",
    "title": "9  Character Sets",
    "section": "9.5 Character Classes",
    "text": "9.5 Character Classes\nClosely related with character sets and character ranges, regular expressions provide another useful construct called character classes which, as their name indicates, are used to match a certain class of characters. The most common character classes in most regex engines are:\n\n\n\n\n\n\n\n\nCharacter\nMatches\nSame as\n\n\n\n\n\\\\d\nany digit\n[0-9]\n\n\n\\\\D\nany nondigit\n[^0-9]\n\n\n\\\\s\nany whitespace character\n[\\f\\n\\r\\t\\v]\n\n\n\\\\S\nany nonwhitespace character\n[^\\f\\n\\r\\t\\v]\n\n\n\\\\w\nany character considered part of a word\n[a-zA-Z0-9_]\n\n\n\\\\W\nany character not considered part of a word\n[^a-zA-Z0-9_]\n\n\n\\\\b\nany word boundary\n\n\n\n\\\\B\nany non-(word boundary)\n\n\n\n\nYou can think of character classes as another type of metacharacters, or as shortcuts for special character sets.\n\n# replace digit with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\d\", \"_\")\n\n[1] \"the dandelion war _010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\d\", \"_\")\n\n[1] \"the dandelion war ____\"\n\n\n\n# replace non-digit with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\D\", \"_\")\n\n[1] \"_he dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\D\", \"_\")\n\n[1] \"__________________2010\"\n\n\nSpaces and non-spaces\n\n# replace space with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\s\", \"_\")\n\n[1] \"the_dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\s\", \"_\")\n\n[1] \"the_dandelion_war_2010\"\n\n\n\n# replace non-space with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\S\", \"_\")\n\n[1] \"_he dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\S\", \"_\")\n\n[1] \"___ _________ ___ ____\"\n\n\nWords and non-words\n\n# replace word with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\b\", \"_\")\n\n[1] \"_the dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\b\", \"_\")\n\n[1] \"_the_ _dandelion_ _war_ _2010_\"\n\n\n\n# replace non-word with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\B\", \"_\")\n\n[1] \"t_he dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\B\", \"_\")\n\n[1] \"t_h_e d_a_n_d_e_l_i_o_n w_a_r 2_0_1_0\"\n\n\nWord boundaries and non-word-boundaries\n\n# replace word boundary with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\w\", \"_\")\n\n[1] \"_he dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\w\", \"_\")\n\n[1] \"___ _________ ___ ____\"\n\n\n\n# replace non-word boundary with '_'\nstr_replace(\"the dandelion war 2010\", \"\\\\W\", \"_\")\n\n[1] \"the_dandelion war 2010\"\n\nstr_replace_all(\"the dandelion war 2010\", \"\\\\W\", \"_\")\n\n[1] \"the_dandelion_war_2010\"\n\n\nThe following table shows the characters that represent whitespaces:\n\n\n\nCharacter\nDescription\n\n\n\n\n\\f\nform feed\n\n\n\\n\nline feed\n\n\n\\r\ncarriage return\n\n\n\\t\ntab\n\n\n\\v\nvertical tab\n\n\n\nSometimes you have to deal with nonprinting whitespace characters. In these situations you probably will end up using the whitespace character class \\\\s. A common example is when you have to match tab characters, or line breaks.\nThe operating system Windows uses \\r\\n as an end-of-line marker. In contrast, Unix-like operating systems (including Mac OS) use \\n.\nTab characters \\t are commonly used as a field-separator for data files. But most text editors render them as whitespaces."
  },
  {
    "objectID": "09-regex-charsets.html#posix-character-classes",
    "href": "09-regex-charsets.html#posix-character-classes",
    "title": "9  Character Sets",
    "section": "9.6 POSIX Character Classes",
    "text": "9.6 POSIX Character Classes\nWe finish this chapter with the introduction of another type of character classes known as POSIX character classes. These are yet another class construct that is supported by the regex engine in R.\n\n\n\nClass\nDescription\nSame as\n\n\n\n\n[:alnum:]\nany letter or digit\n[a-zA-Z0-9]\n\n\n[:alpha:]\nany letter\n[a-zA-Z]\n\n\n[:digit:]\nany digit\n[0-9]\n\n\n[:lower:]\nany lower case letter\n[a-z]\n\n\n[:upper:]\nany upper case letter\n[A-Z]\n\n\n[:space:]\nany whitespace including space\n[\\f\\n\\r\\t\\v ]\n\n\n[:punct:]\nany punctuation symbol\n\n\n\n[:print:]\nany printable character\n\n\n\n[:graph:]\nany printable character excluding space\n\n\n\n[:xdigit:]\nany hexadecimal digit\n[a-fA-F0-9]\n\n\n[:cntrl:]\nASCII control characters\n\n\n\n\nNotice that a POSIX character class is formed by an opening bracket [, followed by a colon :, followed by some keyword, followed by another colon :, and finally a closing bracket ].\nIn order to use them in R, you have to wrap a POSIX class inside a regex character class. That is, you have to surround a POSIX class with brackets.\nOnce again, refer to the pnx vector to illustrate the use of POSIX classes:\n\npnx <- c('pan', 'pen', 'pin', 'p0n', 'p.n', 'p1n', 'paun')\n\nLet’s start with the [:alpha:] class, and see what does it match in pnx:\n\nstr_view(pnx, \"[[:alpha:]]\")\n\nNow let’s test it with [:digit:]\n\nstr_view(pnx, \"[[:digit:]]\")\n\nHere’s another example, suppose we are dealing with the following string:\n\n# la vie (string)\nla_vie <- \"La vie en #FFC0CB (rose);\\nCes't la vie! \\ttres jolie\"\n\n# if you print 'la_vie'\nprint(la_vie)\n\n[1] \"La vie en #FFC0CB (rose);\\nCes't la vie! \\ttres jolie\"\n\n# if you cat 'la_vie'\ncat(la_vie)\n\nLa vie en #FFC0CB (rose);\nCes't la vie!   tres jolie\n\n\nHere’s what would happen to the string la_vie if we apply some substitutions with the POSIX character classes:\n\n# remove space characters\nstr_replace_all(la_vie, pattern=\"[[:blank:]]\", replacement='')\n\n[1] \"Lavieen#FFC0CB(rose);\\nCes'tlavie!tresjolie\"\n\n# remove digits\nstr_replace_all(la_vie, pattern=\"[[:punct:]]\", replacement='')\n\n[1] \"La vie en FFC0CB rose\\nCest la vie \\ttres jolie\"\n\n# remove digits\nstr_replace_all(la_vie, pattern=\"[[:xdigit:]]\", replacement='')\n\n[1] \"L vi n # (ros);\\ns't l vi! \\ttrs joli\"\n\n# remove printable characters\nstr_replace_all(la_vie, pattern=\"[[:print:]]\", replacement='')\n\n[1] \"\\n\\t\"\n\n# remove non-printable characters\nstr_replace_all(la_vie, pattern=\"[^[:print:]]\", replacement='')\n\n[1] \"La vie en #FFC0CB (rose);Ces't la vie! tres jolie\"\n\n# remove graphical characters\nstr_replace_all(la_vie, pattern=\"[[:graph:]]\", replacement='')\n\n[1] \"    \\n   \\t \"\n\n# remove non-graphical characters\nstr_replace_all(la_vie, pattern=\"[^[:graph:]]\", replacement='')\n\n[1] \"Lavieen#FFC0CB(rose);Ces'tlavie!tresjolie\""
  },
  {
    "objectID": "10-regex-anchors.html",
    "href": "10-regex-anchors.html",
    "title": "10  Anchors",
    "section": "",
    "text": "In this chapter, we discuss the regex topics known as anchors and quantifiers."
  },
  {
    "objectID": "10-regex-anchors.html#anchors",
    "href": "10-regex-anchors.html#anchors",
    "title": "10  Anchors",
    "section": "10.1 Anchors",
    "text": "10.1 Anchors\nAnchors are metacharacters that help us assert the position, say, the beginning or end of the string.\n\n\n\n\n\n\n\n\nAnchor\nDescription\nExample\n\n\n\n\n^\nMatches a line starting with the substring.\n^New\n\n\n\\\\$\nMatches a line ending with the substring.\ny$\n\n\n^ \\\\$\nMatches a line that starts and ends with substring, i.e., exact match.\n^Hi There$\n\n\n\\\\A\nMatches input starting with the substring.\n\\\\AHello\n\n\n\\\\Z and \\\\z\nMatches input ending with the substring. \\\\Z also matches if there is a newline after the substring.\nEnd\\\\Z\n\n\n\nAs an example, we will consider a simple character vector universities containing names of some universities.\n\nuniversities <- c(\n  \"University of California, Berkeley\",\n  \"University of California, San Francisco\",\n  \"San Francisco State University\", \n  \"California State University\")\n\nuniversities\n\n[1] \"University of California, Berkeley\"     \n[2] \"University of California, San Francisco\"\n[3] \"San Francisco State University\"         \n[4] \"California State University\"            \n\n\n\n10.1.1 Start of String\nLet’s try to detect university names that begin with University. To do this, we use str_detect() from the \"stringr\" package. Obviously, we need to provide a useful regex pattern that looks for the word University at the beginning of the text. How do we do this? With the caret ^ metacharacter to match for a starting anchor, followed by the string we want to match: \"^University\"\n\nstr_detect(universities, \"^University\")\n\n[1]  TRUE  TRUE FALSE FALSE\n\n\nAs you can tell, only the first and second elements in universities are being matched.\n\nstr_extract(universities, \"^University\")\n\n[1] \"University\" \"University\" NA           NA          \n\nuniversities[str_detect(universities, \"^University\")]\n\n[1] \"University of California, Berkeley\"     \n[2] \"University of California, San Francisco\"\n\n\n\n\n10.1.2 End of String\nNow let’s try to detect university names that end with the word University. To do this, we have to use the metacharacter $ to indicate the ending anchor, forming the pattern: \"University\\$\".\n\nstr_detect(universities, regex(\"University$\"))\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\nCompared to the previous exmaple, now only the third and fourth elements in universities are being matched.\n\nstr_extract(universities, \"University$\")\n\n[1] NA           NA           \"University\" \"University\"\n\nuniversities[str_detect(universities, \"University$\")]\n\n[1] \"San Francisco State University\" \"California State University\"   \n\n\nTo make things more interesting, we have modified the content of vector universities, now consisting of multiple lines (notice the newline characters \\).\n\nuniversities <- c(\n  \"University of California, Berkeley\n  \\nUniversity of California, San Francisco\n  \\nSan Francisco State University\n  \\nCalifornia State University\\n\")\n\ncat(universities)\n\nUniversity of California, Berkeley\n  \nUniversity of California, San Francisco\n  \nSan Francisco State University\n  \nCalifornia State University\n\n\nSay we are interested in extracting university names that end with the word University. We can try using str_extract() with the pattern University\\$\n\nstr_detect(universities, \"University$\")\n\n[1] TRUE\n\nuniversities[str_detect(universities, \"University$\")]\n\n[1] \"University of California, Berkeley\\n  \\nUniversity of California, San Francisco\\n  \\nSan Francisco State University\\n  \\nCalifornia State University\\n\"\n\n\nSomething was match, but what exactly? str_view() can give us the answer to this question:\n\nstr_view(universities, \"University$\")\n\nNotice that the matched effectively occurred at the very end of the string in universitites. But what if what we are really interested in is in matching the names San Francisco State University as well as California State University?\nWe shall use str_extract_all() instead of str_extract() to extract all occurances of the pattern. In addition, the pattern should be specified inside the regex() function, using its multiline argument to tell R to expect input consisting of multiple lines. Here’s how:\n\nstr_extract_all(universities, \n                regex(\"[A-z ]*University$\", multiline = TRUE))\n\n[[1]]\n[1] \"San Francisco State University\" \"California State University\"   \n\n\nLastly, let’s try to extract the last word of our input from previous example.\nUsing str_extract() or str_extract_all() does not matter anymore. While we get a single output for both, the former returns a list and the latter returns a list of lists.\n\nstr_extract(universities, regex(\"[A-z]+\\\\Z\", multiline = TRUE))\n\n[1] \"University\"\n\n\nNotice that \\\\Z works even in presence of a terminating newline \\n. However, when we use \\\\z, this won’t work until we remove the terminating \\n.\n\nstr_extract(universities, regex(\"[A-z ]+\\\\z\", multiline = TRUE))\n\n[1] NA\n\n\nWith the newline terminator removed from the input, \\\\z works just as well.\n\nuniversities <- c(\n  \"University of Southern California\n  \\nCalifornia State University\n  \\nStanford University\n  \\nUniversity of California, Berkeley\")\n\nstr_extract(universities, regex(\"[A-z ]+\\\\Z\", multiline = TRUE))\n\n[1] \" Berkeley\"\n\nstr_extract(universities, regex(\"[A-z ]+\\\\z\", multiline = TRUE))\n\n[1] \" Berkeley\""
  },
  {
    "objectID": "11-regex-quantifiers.html",
    "href": "11-regex-quantifiers.html",
    "title": "11  Quantifiers",
    "section": "",
    "text": "Another important set of regex metacharacters are the so-called quantifiers. These are used when we want to match a certain number of characters that meet certain criteria."
  },
  {
    "objectID": "11-regex-quantifiers.html#quantifier-metacharacters",
    "href": "11-regex-quantifiers.html#quantifier-metacharacters",
    "title": "11  Quantifiers",
    "section": "11.1 Quantifier Metacharacters",
    "text": "11.1 Quantifier Metacharacters\nAs the name indicates, quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.\nThe following table shows the regex quantifiers. The quantifier should be placed after the character, group or character class that is being quantified, denoted as c in the table below.\n\n\n\n\n\n\n\nQuantifier\nDescription\n\n\n\n\nc?\nThe preceding item is optional and will be matched at most once\n\n\nc*\nThe preceding item will be matched zero or more times\n\n\nc+\nThe preceding item will be matched one or more times\n\n\nc{n}\nThe preceding item is matched exactly n times\n\n\nc{n,}\nThe preceding item is matched n or more times\n\n\nc{n,m}\nThe preceding item is matched at least n times, but no more than m times\n\n\n\nFor illustration purposes, let’s create a vector people\n\npeople <- c(\n  \"rori\", \n  \"emilia\", \n  \"matteo\", \n  \"mehmet\", \n  \"filipe\", \n  \"ana\", \n  \"victoria\")\n\npeople\n\n[1] \"rori\"     \"emilia\"   \"matteo\"   \"mehmet\"   \"filipe\"   \"ana\"      \"victoria\"\n\n\nWe start with a simple example extracting all those names that contain at least five characters but no more than 7 characters. To do this, we define a pattern formed by the start anchor ^, followed by a range of upper and lower case letters [A-z], followed by the repetition pattern {5,7}, followed by the end anchor $\n\nstr_extract(people, \"^[A-z]{5,7}$\")\n\n[1] NA       \"emilia\" \"matteo\" \"mehmet\" \"filipe\" NA       NA      \n\n\nThe reason why we use anchors ^ and $ is to make sure that we have an exact match.\nLet’s try to detect names of those individuals with one or more a or e.\n\nstr_detect(people, \"[ae]+\")\n\n[1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\npeople[str_detect(people, \"[ae]+\")]\n\n[1] \"emilia\"   \"matteo\"   \"mehmet\"   \"filipe\"   \"ana\"      \"victoria\"\n\n\nIn the last example, if we want to extract names that contain a or e we could follow this simple implementation. Points to note here:\n\nCharacter set [ae] could appear 1 or more times so we use the quantifier +.\n.* matches 0 or any number of characters where . is a wildcard dot and * represents the quantifier 0 or many .\nPattern .*[ae]+.* looks for 1 or more occurrences of [ae] that can be preceeded/followed by any number of other characters.\n\n\npeople <- c(\n  \"rori\", \n  \"emilia\", \n  \"matteo\", \n  \"mehmet\", \n  \"filipe\", \n  \"ana\", \n  \"victoria\")\n\nstr_extract(people, regex(\".*[ae]+.*\"))\n\n[1] NA         \"emilia\"   \"matteo\"   \"mehmet\"   \"filipe\"   \"ana\"      \"victoria\"\n\n\n\n11.1.1 What do groups mean in Regex?\nWe visited character classes in one of the sections. For situations where we would like to group character classes or regex pattern before using a quantifier, we indicate grouping using paranthesis.\nConsider an example where we would like to extract only strings with two names separated by a whitespace. For illustrative purpose, the strings end with a whitespace.\n\npeople <- c(\n  \"rori rholfs\", \n  \"emilia huerta \", \n  \"matteo fumagalli \", \n  \"mehmet \", \n  \"filipe vieira\", \n  \"ana chen\", \n  \"victoria kim \")\n\nstr_extract(people, \"([A-z]+[ ]){2}\")\n\n[1] NA                  \"emilia huerta \"    \"matteo fumagalli \"\n[4] NA                  NA                  NA                 \n[7] \"victoria kim \"    \n\n\nWe could also use pre-built class [:alpha:] in the above example.\n\nstr_extract(people, regex(\"([:alpha:]+[ ]){2}\"))\n\n[1] NA                  \"emilia huerta \"    \"matteo fumagalli \"\n[4] NA                  NA                  NA                 \n[7] \"victoria kim \""
  },
  {
    "objectID": "11-regex-quantifiers.html#greedy-vs-lazy-match",
    "href": "11-regex-quantifiers.html#greedy-vs-lazy-match",
    "title": "11  Quantifiers",
    "section": "11.2 Greedy vs Lazy Match",
    "text": "11.2 Greedy vs Lazy Match\nAs you might have noted in previous cases, regex tend to return greedy results., i.e., the longest match possible for a given expression. Let’s explore this idea further and see if we can force it to be lazy.\nConsider again one of our previous examples, but this time extracting those names that contain at least four characters but no more than 6 characters:\n\npeople <- c(\n  \"rori\", \n  \"emilia\", \n  \"matteo\", \n  \"mehmet\", \n  \"filipe\", \n  \"ana\", \n  \"victoria\")\n\nstr_extract(people, \"^[A-z]{4,6}$\")\n\n[1] \"rori\"   \"emilia\" \"matteo\" \"mehmet\" \"filipe\" NA       NA      \n\n\nThe quantifier {4,6} returned a greedy match, i.e., the result was of the maximum length possible.\nLet us remove the anchors to see whether it is indeed greedy. By removing the anchors, it prints the first 4-6 characters of all names, provided name length is at the minimum 4.\n\nstr_extract(people, regex(\"[A-z]{4,6}\"))\n\n[1] \"rori\"   \"emilia\" \"matteo\" \"mehmet\" \"filipe\" NA       \"victor\"\n\n\nWe could make it lazy by adding a ? after the quantifier. For names emilia, matteo, mehmet, filipe and victoria, it prints only the first 4 characters.\n\nstr_extract(people, regex(\"[A-z]{4,6}?\"))\n\n[1] \"rori\" \"emil\" \"matt\" \"mehm\" \"fili\" NA     \"vict\"\n\n\nSimilarly, we could make other quantifiers lazy.\n\n\n\nOriginal Quantifier (Greedy)\nLazy Version\n\n\n\n\nc?\nc??\n\n\nc*\nc*?\n\n\nc+\nc+?\n\n\nc{n}\nc{n}?\n\n\nc{n,}\nc{n,}?\n\n\nc{n,m}\nc{n,m}?"
  },
  {
    "objectID": "12-regex-boundaries.html",
    "href": "12-regex-boundaries.html",
    "title": "12  Boundaries and Look Arounds",
    "section": "",
    "text": "In chapter 9 we introduced a handful of character classes such as \\d which matches any digit, or \\w which matches any character considered to be part of a word. Among these classes, there are two special metacharacters, \\b and \\B, known as boundaries, that deserve further discussion.\nLikewise, we need to talk about another useful regex concept known as look arounds. The patterns behind this notion will allow us to match tokens around auxiliary tokens are not to be matched."
  },
  {
    "objectID": "12-regex-boundaries.html#boundaries",
    "href": "12-regex-boundaries.html#boundaries",
    "title": "12  Boundaries and Look Arounds",
    "section": "12.1 Boundaries",
    "text": "12.1 Boundaries\nBoundaries are metacharacters too and match based on what preceds or follows current position.\n\n\n\n\n\n\n\n\nBoundary\nDescription\nExample\n\n\n\n\n\\\\b\nMatches a word boundary, i.e., when a side is not [A-z0-9_]\n\\\\bHi \\\\bHi\\\\b\n\n\n\\\\B\nMatches when not a word boundary, i.e., when a side is [A-z0-9_]\n\\\\BHi\n\n\n\nTo understand word boundaries, let us go over a simple example. Consider the string in vector book shown below\n\nbook <- c(\"This book is an irresistible thesis\")\nbook\n\n[1] \"This book is an irresistible thesis\"\n\n\nSuppose we are interested in matching the pattern is.\nIf you observe the text in book, you’ll notice that is appears in the words This, is, irresistible, and this. Depending on which function you use, you will be able to match just the first occurrence\n\n# matching first occurrence\nstr_view(book, \"is\")\n\nor match all occurrences:\n\n# matching all occurrences\nstr_view_all(book, \"is\")\n\nWarning: `str_view()` was deprecated in stringr 1.5.0.\nℹ Please use `str_view_all()` instead.\n\n\nInstead of matching is without any other restriction or condition, we can also think of three additional matching cases that are more concrete:\n\nExtract words that exactly match with is\nExtract words that contain is in between characters\nExtract words that end with is\n\n\nCase 1: Words that exactly match is\nTo match (or extract) words that exactly match the word is, we use the boundary-word pattern \\\\b. Note the optional use of ignore_case argument to regex()\n\nstr_view_all(\n  string = book, \n  pattern = regex(\"\\\\bis\\\\b\", ignore_case = TRUE))\n\n\n\nCase 2: Words containing is in between characters\nTo match words that contain is in between characters, such as “irresistible”, we use the not a word boundary \\\\B on both sides of is:\n\nstr_view_all(\n  string = book, \n  pattern = regex(\"\\\\Bis\\\\B\", ignore_case = TRUE))\n\nTo extract the entire word “irresistible”, we must include [A-z]* on either side of \\\\Bis\\\\B, otherwise the pattern \\\\Bis\\\\B will only match is\n\nstr_extract(\n  string = book, \n  pattern = regex(\"[A-z]*\\\\Bis\\\\B[A-z]*\", ignore_case = TRUE))\n\n[1] \"irresistible\"\n\n\nNotice that we use [A-z]* instead of [A-z]+ to specifically showcase that no other is got matched as * denotes 0 or any.\nYou may ask “What if we don’t surround \\\\Bis\\\\B with [A-z]*?” Here is what happens:\n\nstr_view_all(\n  string = book, \n  pattern = regex(\"[A-z]*\\\\Bis\", ignore_case = TRUE))\n\nThe pattern [A-z]*\\\\Bis matches “This”, “irresis”, and “thesis”, which are extracted as follows:\n\nstr_extract_all(\n  string = book, \n  pattern = regex(\"[A-z]*\\\\Bis\", ignore_case = TRUE))\n\n[[1]]\n[1] \"This\"    \"irresis\" \"thesis\" \n\n\n\n\nCase 3: Match (or extract) words that end with is\nIf you are interested in extracting words that end with is, then you need to use a pattern with the word boundary is\\\\b. Now, you also need to determine if is should be part of a word with one or more preceding word-characters, of if is should not be preceded by any word-characters.\n\n# end with \"is\", with preceding word-characters \nstr_view_all(\n  string = book, \n  pattern = regex(\"[A-z]+is\\\\b\", ignore_case = TRUE))\n\n\n# end with \"is\", without preceding word-characters \nstr_view_all(\n  string = book, \n  pattern = regex(\"\\\\bis\\\\b\", ignore_case = TRUE))"
  },
  {
    "objectID": "12-regex-boundaries.html#look-arounds",
    "href": "12-regex-boundaries.html#look-arounds",
    "title": "12  Boundaries and Look Arounds",
    "section": "12.2 Look Arounds",
    "text": "12.2 Look Arounds\nAs the name suggests, this type of pattern allows us to look around the string in order to match the desired pattern. To be more precise, look arounds indicate positions just like anchors, $ and ^.\nThere are four types of look arounds, listed in the following table.\n\n\n\n\n\n\n\n\nLook Around\nNotation\nDescription\n\n\n\n\nPositive Look Ahead\nA(?=pattern)\nCheck if pattern follows A\n\n\nNegative Look Ahead\nA(?!pattern)\nCheck if pattern does not follow A\n\n\nPositive Look Behind\n(?<=pattern)A\nCheck if pattern precedes A\n\n\nNegative Look Behind\n(?<!pattern)A\nCheck if pattern does not preced A\n\n\n\nIn this table, A refers to a character set or group that we are trying to match.\n\n12.2.1 Look Aheads\nLet us look at some examples for Look Aheads. To do this, consider the vector heights shown below\n\nheights <- c(\"40cm\", \"23\", \"60cm\", \"57\", \"133cm\")\nheights\n\n[1] \"40cm\"  \"23\"    \"60cm\"  \"57\"    \"133cm\"\n\n\nSuppose we want to extract the heights without the unit of measurement, that is, we want to obtain the numeric values but not the letters cm. We can do this by specifying a pattern to match one or more digits [0-9]+\n\nstr_extract(heights, \"[0-9]+\")\n\n[1] \"40\"  \"23\"  \"60\"  \"57\"  \"133\"\n\n\nLet’s change the format of heights by collapsing all of its elements into a single string, with height values separated by commas:\n\nheights <- paste(heights, collapse = \", \")\nheights\n\n[1] \"40cm, 23, 60cm, 57, 133cm\"\n\n\nWith this modified heights, if we use the previous command, we only extract the first occurrence:\n\nstr_extract(heights, \"[0-9]+\")\n\n[1] \"40\"\n\n\nIn order to extract all occurrences, we must use str_extract_all()\n\nstr_extract_all(heights, \"[0-9]+\")\n\n[[1]]\n[1] \"40\"  \"23\"  \"60\"  \"57\"  \"133\"\n\n\nLet’s change our input to contain heights that are in inches\n\nheights <- \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\nheights\n\n[1] \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\n\n\nand reapply the previous command\n\nstr_extract_all(heights, \"[0-9]+\")\n\n[[1]]\n[1] \"40\"  \"23\"  \"60\"  \"57\"  \"133\" \"15\"  \"99\" \n\n\nIn case we want to retrieve only those heights with unit of measurement cm, we could use a positive look ahead. In the syntax A(?=pattern), the pattern we look for would be cm. Any number that is followed by cm will be extracted hence A is [0-9][0-9]+.\nDon’t forget that (?=cm) does not extract cm, it is used to assert position only!\n\nheights <- \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\n\nstr_extract_all(heights, \"[0-9][0-9]+(?=cm)\")\n\n[[1]]\n[1] \"40\"  \"60\"  \"133\"\n\n\nIn case we want to extract all heights that don’t have cm as the unit of measurement, we could use negative look ahead. In the syntax A(?!pattern), the pattern here is cm and A should be character class [0-9] with quantifier + (one or many).\n\nheights <- \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\n\nstr_extract_all(heights, \"[0-9][0-9]+(?!cm)\")\n\n[[1]]\n[1] \"23\" \"57\" \"13\" \"15\" \"99\"\n\n\nSimilarly, using negative look ahead to extract all heights that don’t have cm as the unit of measurement should work too, but in the code snippet below, we get an incorrect output. Can you guess why?\n\nheights <- \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\n\nstr_extract_all(heights, regex(\"[0-9]+(?!cm)\"))\n\n[[1]]\n[1] \"4\"  \"23\" \"6\"  \"57\" \"13\" \"15\" \"99\"\n\n\nThis is incorrect since we extract the 4 from 40cm, 6 from 60cm, and 13 from 133cm additional to our actual answer.\nWe could overcome this by specifically mentioning that the number (height) cannot be followed by:\n\nthe pattern cm\nsome number (i.e, from 40cm, we should not extract 4)\n\nTo do this, we could use alternation, denoted as pipe |, which is similar to OR.\nThe pattern in A(?!pattern) is now cm or [0-9]+, which we can represent as (cm|[0-9]+). Note that our pattern in enclosed within paranthesis.\n\nheights <- \"40cm, 23in, 60cm, 57, 133cm, 15in, 99\"\n\nstr_extract_all(heights, regex(\"[0-9]+(?!(cm|[0-9]+))\"))\n\n[[1]]\n[1] \"23\" \"57\" \"15\" \"99\"\n\n\nThe illustration above is typical of regular expressions. As the test cases become complex, you will have to tweek the expression to include all the corner cases.\n\n\n12.2.2 Look Behinds\nAs the name suggests, this type of metacharacters allows us to look behind the current position for presence or absence of a pattern. This works the same way as look ahead, except that we look for the preceding characters.\nLet us look at some examples.\nConsider a vector courses that has the name and year of some statistics courses over different semesters.\n\ncourses <- c(\n  \"Stat_133 2020\", \n  \"Stat_154 2020\", \n  \"Stat_133 2019\", \n  \"Stat_151 2018\", \n  \"Stat_151 2020\", \n  \"Stat_154 2018\")\n\ncourses\n\n[1] \"Stat_133 2020\" \"Stat_154 2020\" \"Stat_133 2019\" \"Stat_151 2018\"\n[5] \"Stat_151 2020\" \"Stat_154 2018\"\n\n\nWe will use a positive look-behind to extract the years associated to Stat_133. In the syntax (?<=pattern)P, pattern is (Stat_133 ) and P is the semester we want to extract, i.e., [0-9]{4}.\n\ncourses <- c(\n  \"Stat_133 2020\", \n  \"Stat_154 2020\", \n  \"Stat_133 2019\", \n  \"Stat_151 2018\", \n  \"Stat_151 2020\", \n  \"Stat_154 2018\")\n\nstr_extract(courses, regex(\"(?<=(Stat_133 ))[0-9]{4}\"))\n\n[1] \"2020\" NA     \"2019\" NA     NA     NA    \n\n\nSimilarly, we can use a negative look-behind to extract semesters of courses that are not Stat_133. In the syntax (?<!pattern)P, P is [0-9]+ and the pattern is (Stat_133 ).\n\ncourses <- c(\n  \"Stat_133 2020\", \n  \"Stat_154 2020\", \n  \"Stat_133 2019\", \n  \"Stat_151 2018\", \n  \"Stat_151 2020\", \n  \"Stat_154 2018\")\n\nstr_extract(courses, \"(?<!(Stat_133 ))[0-9]{4}\")\n\n[1] NA     \"2020\" NA     \"2018\" \"2020\" \"2018\""
  },
  {
    "objectID": "12-regex-boundaries.html#logical-operators-in-regex",
    "href": "12-regex-boundaries.html#logical-operators-in-regex",
    "title": "12  Boundaries and Look Arounds",
    "section": "12.3 Logical Operators in Regex",
    "text": "12.3 Logical Operators in Regex\nWe don’t have earmarked Logical Operators in Regex, however, a few syntaxes could replicate these.\nWe saw in one of the examples for look aheads that logical OR is expressed using the pipe symbol | in regex. This is also known as ’Alternation` operation.\nThere is no AND in regex, but it can be synthesized using look arounds. For NOT operation, the ^ symbol works in character classes but cannot be used for groups as explained later.\n\n\n\nOperation\nSyntax\nExample\n\n\n\n\nOR\nPipe symbol |\npattern1|pattern2\n\n\nNOT\nCap symbol ^\n[^aeiou]\n\n\nAND\nSynthetic AND\n(?=P1)(?=P2)\n\n\n\n\n12.3.1 Logical OR\nConsider the vector people from a previous example.\n\npeople <- c(\n  \"rori\", \n  \"emilia\", \n  \"matteo\", \n  \"mehmet\", \n  \"filipe\", \n  \"ana\", \n  \"victoria\")\n\npeople\n\n[1] \"rori\"     \"emilia\"   \"matteo\"   \"mehmet\"   \"filipe\"   \"ana\"      \"victoria\"\n\n\nIf we want to display names that are of length 3 OR of length 4, we use the pipe symbol.\n\nstr_extract(people, regex(\"^([A-z]{3}|[A-z]{4})$\"))\n\n[1] \"rori\" NA     NA     NA     NA     \"ana\"  NA    \n\n\nNote that for the above example, we could use quantifier {3,4} and still obtain the same result.\n\nstr_extract(people, regex(\"^([A-z]{3,4})$\"))\n\n[1] \"rori\" NA     NA     NA     NA     \"ana\"  NA    \n\n\n\n\n12.3.2 Logical NOT\nUsing the NOT ^, we could extract names that don’t contain e or u.\n\nstr_extract(people, regex(\"^[^eu]+$\"))\n\n[1] \"rori\"     NA         NA         NA         NA         \"ana\"      \"victoria\"\n\n\nNote that ^ operation cannot be used for groups. This is because it is unclear in such cases if we are using ^ as a NOT operator or an anchor. In such cases we could use a negative look around. Let’s say, we have a group (ia) and we want to extract names without the group (ia).\n\nstr_extract(people, regex(\"^(?!.*ia).*$\"))\n\n[1] \"rori\"   NA       \"matteo\" \"mehmet\" \"filipe\" \"ana\"    NA      \n\n\n\n\n12.3.3 Logical AND\nConsider a case where we want to extract names with length greater than 4 and containing letter o. We have two conditions and we need to AND them.\n\nCondition 1: Length > 4, the pattern is (?=.{5,})\nCondition 2: Contains o, the pattern is (?=.*o)\n\nThe two conditions can be used together.\n\npeople <- c(\n  \"rori\", \n  \"emilia\", \n  \"matteo\", \n  \"mehmet\", \n  \"filipe\", \n  \"ana\", \n  \"victoria\")\n\nstr_extract(people, regex(\"(?=.{5,})(?=.*o).*\"))\n\n[1] NA         NA         \"matteo\"   NA         NA         NA         \"victoria\""
  },
  {
    "objectID": "13-regex-stringr.html",
    "href": "13-regex-stringr.html",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "",
    "text": "In the previous chapters we talked about regular expressions in general; we discussed the particular way in which R works with regex patterns; and we quickly presented some functions to manipulate strings with regular expressions. In this chapter we are going to describe in more detail the functions for regular expressions available in both the \"stringr\" package.\nAs you know, we have already presented some of the functions in the R package \"stringr\" for regular expressions. As we mentioned, all these functions share a common usage structure:\nThe main two arguments are: a string vector to be processed, and a single pattern (i.e. regular expression) to match. Moreover, all the function names begin with the prefix str_, followed by the name of the action to be performed. For example, to locate the position of the first occurrence, we should use str_locate(); to locate the positions of all matches we should use str_locate_all()."
  },
  {
    "objectID": "13-regex-stringr.html#detecting-patterns-with-str_detect",
    "href": "13-regex-stringr.html#detecting-patterns-with-str_detect",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.1 Detecting patterns with str_detect()",
    "text": "13.1 Detecting patterns with str_detect()\nFor detecting whether a pattern is present (or absent) in a string vector, we can use the function str_detect(). Actually, this function is a wraper of grepl():\n\n# some objects\nsome_objs <- c(\"pen\", \"pencil\", \"marker\", \"spray\")\n\n# detect phones\nstr_detect(some_objs, \"pen\")\n\n[1]  TRUE  TRUE FALSE FALSE\n\n# select detected macthes\nsome_objs[str_detect(some_objs, \"pen\")]\n\n[1] \"pen\"    \"pencil\"\n\n\nAs you can see, the output of str_detect() is a boolean vector (TRUE/FALSE) of the same length as the specified string. You get a TRUE if a match is detected in a string, FALSE otherwise. Here’s another more elaborated example in which the pattern matches dates of the form day-month-year:\n\n# some strings\nstrings <- c(\"12 Jun 2002\", \" 8 September 2004 \", \"22-July-2009 \", \n            \"01 01 2001\", \"date\", \"02.06.2000\", \n            \"xxx-yyy-zzzz\", \"$2,600\")\n\n# date pattern (month as text)\ndates = \"([0-9]{1,2})[- .]([a-zA-Z]+)[- .]([0-9]{4})\"\n\n# detect dates\nstr_detect(strings, dates)\n\n[1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "13-regex-stringr.html#extract-first-match-with-str_extract",
    "href": "13-regex-stringr.html#extract-first-match-with-str_extract",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.2 Extract first match with str_extract()",
    "text": "13.2 Extract first match with str_extract()\nFor extracting a string containing a pattern, we can use the function str_extract(). In fact, this function extracts the first piece of a string that matches a given pattern. For example, imagine that we have a character vector with some tweets about Paris, and that we want to extract the hashtags. We can do this simply by defining a #hashtag pattern like #[a-zA-Z]{1}\n\n# tweets about 'Paris'\nparis_tweets <- c(\n  \"#Paris is chock-full of cultural and culinary attractions\",\n  \"Some time in #Paris along Canal St.-Martin famous by #Amelie\",\n  \"While you're in #Paris, stop at cafe: http://goo.gl/yaCbW\",\n  \"Paris, the city of light\")\n\n# hashtag pattern\nhash <- \"#[a-zA-Z]{1,}\"\n\n# extract (first) hashtag\nstr_extract(paris_tweets, hash)\n\n[1] \"#Paris\" \"#Paris\" \"#Paris\" NA      \n\n\nAs you can tell, the output of str_extract() is a vector of same length as string. Those elements that don’t match the pattern are indicated as NA. Note that str_extract() only matches the first pattern: it didn’t extract the hashtag \"#Amelie\"."
  },
  {
    "objectID": "13-regex-stringr.html#extract-all-matches-with-str_extract_all",
    "href": "13-regex-stringr.html#extract-all-matches-with-str_extract_all",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.3 Extract all matches with str_extract_all()",
    "text": "13.3 Extract all matches with str_extract_all()\nIn addition to str_extract(), \"stringr\" also provides the function str_extract_all(). As its name indicates, we use str_extract_all() to extract all patterns in a vector string. Taking the same string as in the previous example, we can extract all the hashtag matches like so:\n\n# extract (all) hashtags\nstr_extract_all(paris_tweets, \"#[a-zA-Z]{1,}\")\n\n[[1]]\n[1] \"#Paris\"\n\n[[2]]\n[1] \"#Paris\"  \"#Amelie\"\n\n[[3]]\n[1] \"#Paris\"\n\n[[4]]\ncharacter(0)\n\n\nCompared to str_extract(), the output of str_extract_all() is a list of same length as string. In addition, those elements that don’t match the pattern are indicated with an empty character vector character(0) instead of NA."
  },
  {
    "objectID": "13-regex-stringr.html#extract-first-match-group-with-str_match",
    "href": "13-regex-stringr.html#extract-first-match-group-with-str_match",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.4 Extract first match group with str_match()",
    "text": "13.4 Extract first match group with str_match()\nClosely related to str_extract() the package \"stringr\" offers another extracting function: str_match(). This function not only extracts the matched pattern but it also shows each of the matched groups in a regex character class pattern.\n\n# string vector\nstrings <- c(\"12 Jun 2002\", \" 8 September 2004 \", \"22-July-2009 \", \n            \"01 01 2001\", \"date\", \"02.06.2000\", \n            \"xxx-yyy-zzzz\", \"$2,600\")\n\n# date pattern (month as text)\ndates = \"([0-9]{1,2})[- .]([a-zA-Z]+)[- .]([0-9]{4})\"\n\n# extract first matched group\nstr_match(strings, dates)\n\n     [,1]               [,2] [,3]        [,4]  \n[1,] \"12 Jun 2002\"      \"12\" \"Jun\"       \"2002\"\n[2,] \"8 September 2004\" \"8\"  \"September\" \"2004\"\n[3,] \"22-July-2009\"     \"22\" \"July\"      \"2009\"\n[4,] NA                 NA   NA          NA    \n[5,] NA                 NA   NA          NA    \n[6,] NA                 NA   NA          NA    \n[7,] NA                 NA   NA          NA    \n[8,] NA                 NA   NA          NA    \n\n\nNote that the output is not a vector but a character matrix. The first column is the complete match, the other columns are each of the captured groups. For those unmatched elements, there is a missing value NA."
  },
  {
    "objectID": "13-regex-stringr.html#extract-all-matched-groups-with-str_match_all",
    "href": "13-regex-stringr.html#extract-all-matched-groups-with-str_match_all",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.5 Extract all matched groups with str_match_all()",
    "text": "13.5 Extract all matched groups with str_match_all()\nIf what we’re looking for is extracting all patterns in a string vector, instead of using str_extract() we should use str_extract_all():\n\n# tweets about 'Paris'\nparis_tweets <- c(\n  \"#Paris is chock-full of cultural and culinary attractions\",\n  \"Some time in #Paris along Canal St.-Martin famous by #Amelie\",\n  \"While you're in #Paris, stop at cafe: http://goo.gl/yaCbW\",\n  \"Paris, the city of light\")\n\n# match (all) hashtags in 'paris_tweets'\nstr_match_all(paris_tweets, \"#[a-zA-Z]{1,}\")\n\n[[1]]\n     [,1]    \n[1,] \"#Paris\"\n\n[[2]]\n     [,1]     \n[1,] \"#Paris\" \n[2,] \"#Amelie\"\n\n[[3]]\n     [,1]    \n[1,] \"#Paris\"\n\n[[4]]\n     [,1]\n\n\nCompared to str_match(), the output of str_match_all() is a list. Note al also that each element of the list is a matrix with as many rows as hashtag matches. In turn, those elements that don’t match the pattern are indicated with an empty character vector character(0) instead of a NA."
  },
  {
    "objectID": "13-regex-stringr.html#locate-first-match-with-str_locate",
    "href": "13-regex-stringr.html#locate-first-match-with-str_locate",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.6 Locate first match with str_locate()",
    "text": "13.6 Locate first match with str_locate()\nBesides detecting, extracting and matching regex patterns, \"stringr\" allows us to locate occurrences of patterns. For locating the position of the first occurrence of a pattern in a string vector, we should use str_locate().\n\n# locate position of (first) hashtag\nstr_locate(paris_tweets, \"#[a-zA-Z]{1,}\")\n\n     start end\n[1,]     1   6\n[2,]    14  19\n[3,]    17  22\n[4,]    NA  NA\n\n\nThe output of str_locate() is a matrix with two columns and as many rows as elements in the (string) vector. The first column of the output is the start position, while the second column is the end position.\nIn the previous example, the result is a matrix with 4 rows and 2 columns. The first row corresponds to the hashtag of the first tweet. It starts at position 1 and ends at position 6. The second row corresponds to the hashtag of the second tweet; its start position is the 14th character, and its end position is the 19th character. The fourth row corresponds to the fourth tweet. Since there are no hashtags the values in that row are NA’s."
  },
  {
    "objectID": "13-regex-stringr.html#locate-all-matches-with-str_locate_all",
    "href": "13-regex-stringr.html#locate-all-matches-with-str_locate_all",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.7 Locate all matches with str_locate_all()",
    "text": "13.7 Locate all matches with str_locate_all()\nTo locate not just the first but all the occurrence patterns in a string vector, we should use str_locate_all():\n\n# locate (all) hashtags in 'paris_tweets'\nstr_locate_all(paris_tweets, \"#[a-zA-Z]{1,}\")\n\n[[1]]\n     start end\n[1,]     1   6\n\n[[2]]\n     start end\n[1,]    14  19\n[2,]    54  60\n\n[[3]]\n     start end\n[1,]    17  22\n\n[[4]]\n     start end\n\n\nCompared to str_locate(), the output of str_locate_all() is a list of the same length as the provided string. Each of the list elements is in turn a matrix with two columns. Those elements that don’t match the pattern are indicated with an empty character vector instead of an NA.\nLooking at the obtained result from applying str_locate_all() to paris_tweets, you can see that the second element contains the start and end positions for both hashtags #Paris and #Amelie. In turn, the fourth element appears empty since its associated tweet contains no hashtags."
  },
  {
    "objectID": "13-regex-stringr.html#replace-first-match-with-str_replace",
    "href": "13-regex-stringr.html#replace-first-match-with-str_replace",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.8 Replace first match with str_replace()",
    "text": "13.8 Replace first match with str_replace()\nFor replacing the first occurrence of a matched pattern in a string, we can use str_replace(). Its usage has the following form:\nstr_replace(string, pattern, replacement)\nIn addition to the main 2 inputs of the rest of functions, str_replace() requires a third argument that indicates the replacement pattern.\nSay we have the city names of San Francisco, Barcelona, Naples and Paris in a vector. And let’s suppose that we want to replace the first vowel in each name with a semicolon. Here’s how we can do that:\n\n# city names\ncities <- c(\"San Francisco\", \"Barcelona\", \"Naples\", \"Paris\")\n\n# replace first matched vowel\nstr_replace(cities, \"[aeiou]\", \";\")\n\n[1] \"S;n Francisco\" \"B;rcelona\"     \"N;ples\"        \"P;ris\"        \n\n\nNow, suppose that we want to replace the first consonant in each name. We just need to modify the pattern with a negated class:\n\n# replace first matched consonant\nstr_replace(cities, \"[^aeiou]\", \";\")\n\n[1] \";an Francisco\" \";arcelona\"     \";aples\"        \";aris\""
  },
  {
    "objectID": "13-regex-stringr.html#replace-all-matches-with-str_replace_all",
    "href": "13-regex-stringr.html#replace-all-matches-with-str_replace_all",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.9 Replace all matches with str_replace_all()",
    "text": "13.9 Replace all matches with str_replace_all()\nFor replacing all occurrences of a matched pattern in a string, we can use str_replace_all(). Once again, consider a vector with some city names, and let’s suppose that we want to replace all the vowels in each name:\n\n# city names\ncities <- c(\"San Francisco\", \"Barcelona\", \"Naples\", \"Paris\")\n\n# replace all matched vowel\nstr_replace_all(cities, pattern=\"[aeiou]\", \";\")\n\n[1] \"S;n Fr;nc;sc;\" \"B;rc;l;n;\"     \"N;pl;s\"        \"P;r;s\"        \n\n\nAlternatively, to replace all consonants with a semicolon in each name, we just need to change the pattern with a negated class:\n\n# replace all matched consonants\nstr_replace_all(cities, pattern=\"[^aeiou]\", \";\")\n\n[1] \";a;;;;a;;i;;o\" \";a;;e;o;a\"     \";a;;e;\"        \";a;i;\""
  },
  {
    "objectID": "13-regex-stringr.html#string-splitting-with-str_split",
    "href": "13-regex-stringr.html#string-splitting-with-str_split",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.10 String splitting with str_split()",
    "text": "13.10 String splitting with str_split()\nSimilar to strsplit(), \"stringr\" gives us the function str_split() to separate a character vector into a number of pieces. This function has the following usage:\nstr_split(string, pattern, n = Inf)\nThe argument n is the maximum number of pieces to return. The default value (n= Inf) implies that all possible split positions are used.\nLet’s see the same example of strsplit() in which we wish to split up a sentence into individuals words:\n\n# a sentence\nsentence <- c(\"R is a collaborative project with many contributors\")\n\n# split into words\nstr_split(sentence, \" \")\n\n[[1]]\n[1] \"R\"             \"is\"            \"a\"             \"collaborative\"\n[5] \"project\"       \"with\"          \"many\"          \"contributors\" \n\n\nLikewise, we can break apart the portions of a telephone number by splitting those sets of digits joined by a dash \"-\"\n\n# telephone numbers\ntels = c(\"510-548-2238\", \"707-231-2440\", \"650-752-1300\")\n\n# split each number into its portions\nstr_split(tels, \"-\")\n\n[[1]]\n[1] \"510\"  \"548\"  \"2238\"\n\n[[2]]\n[1] \"707\"  \"231\"  \"2440\"\n\n[[3]]\n[1] \"650\"  \"752\"  \"1300\"\n\n\nThe result is a list of character vectors. Each element of the string vector corre- sponds to an element in the resulting list. In turn, each of the list elements will contain the split vectors (i.e. number of pieces) occurring from the matches.\nIn order to show the use of the argument n, let’s consider a vector with flavors \"chocolate\", \"vanilla\", \"cinnamon\", \"mint\", and \"lemon\". Suppose we want to split each flavor name defining as pattern the class of vowels:\n\n# string\nflavors <- c(\"chocolate\", \"vanilla\", \"cinnamon\", \"mint\", \"lemon\")\n\n# split by vowels\nstr_split(flavors, \"[aeiou]\")\n\n[[1]]\n[1] \"ch\" \"c\"  \"l\"  \"t\"  \"\"  \n\n[[2]]\n[1] \"v\"  \"n\"  \"ll\" \"\"  \n\n[[3]]\n[1] \"c\"  \"nn\" \"m\"  \"n\" \n\n[[4]]\n[1] \"m\"  \"nt\"\n\n[[5]]\n[1] \"l\" \"m\" \"n\"\n\n\nNow let’s modify the maximum number of pieces to n = 2. This means that str_split() will split each element into a maximum of 2 pieces. Here’s what we obtain:\n\n# split by first vowel\nstr_split(flavors, \"[aeiou]\", n=2)\n\n[[1]]\n[1] \"ch\"     \"colate\"\n\n[[2]]\n[1] \"v\"     \"nilla\"\n\n[[3]]\n[1] \"c\"      \"nnamon\"\n\n[[4]]\n[1] \"m\"  \"nt\"\n\n[[5]]\n[1] \"l\"   \"mon\""
  },
  {
    "objectID": "13-regex-stringr.html#string-splitting-with-str_split_fixed",
    "href": "13-regex-stringr.html#string-splitting-with-str_split_fixed",
    "title": "13  Regex Functions in \"stringr\"",
    "section": "13.11 String splitting with str_split_fixed()",
    "text": "13.11 String splitting with str_split_fixed()\nIn addition to str_split(), there is also the str_split_fixed() function that splits up a string into a fixed number of pieces. Its usage has the following form:\nstr_split_fixed(string, pattern, n)\nNote that the argument n does not have a default value. In other words, we need to specify an integer to indicate the number of pieces.\nConsider again the same vector of flavors, and the letter \"n\" as the pattern to match. Let’s see the behavior of str_split_fixed() with n = 2.\n\n# string\nflavors <- c(\"chocolate\", \"vanilla\", \"cinnamon\", \"mint\", \"lemon\")\n\n# split flavors into 2 pieces\nstr_split_fixed(flavors, \"n\", 2)\n\n     [,1]        [,2]   \n[1,] \"chocolate\" \"\"     \n[2,] \"va\"        \"illa\" \n[3,] \"ci\"        \"namon\"\n[4,] \"mi\"        \"t\"    \n[5,] \"lemo\"      \"\"     \n\n\nThe output is a character matrix with as many columns as n = 2. Since \"chocolate\" does not contain any letter \"n\", its corresponding value in the second column remains empty \"\". In contrast, the value of the second column associated to \"lemon\" is also empty. But this is because this flavor is split up into \"lemo\" and \"\".\nIf we change the value n = 3, we will obtain a matrix with three columns:\n\n# split favors into 3 pieces\nstr_split_fixed(flavors, \"n\", 3)\n\n     [,1]        [,2]   [,3]  \n[1,] \"chocolate\" \"\"     \"\"    \n[2,] \"va\"        \"illa\" \"\"    \n[3,] \"ci\"        \"\"     \"amon\"\n[4,] \"mi\"        \"t\"    \"\"    \n[5,] \"lemo\"      \"\"     \"\""
  },
  {
    "objectID": "14-regex-baser.html",
    "href": "14-regex-baser.html",
    "title": "14  Regex Functions in R",
    "section": "",
    "text": "In the previous chapters we talked about regex functions available in the package \"stringr\". In this chapter we are going to describe more regular expression functions but this time from the \"base\" package (i.e. native regex functions in R)."
  },
  {
    "objectID": "14-regex-baser.html#pattern-finding-functions",
    "href": "14-regex-baser.html#pattern-finding-functions",
    "title": "14  Regex Functions in R",
    "section": "14.1 Pattern Finding Functions",
    "text": "14.1 Pattern Finding Functions\nLet’s begin by reviewing the first five grep()-like functions grep(), grepl(), regexpr(), gregexpr(), and regexec(). The goal is the same for all these functions: finding a match. The difference between them is in the format of the output. Essentially these functions require two main arguments: a pattern (i.e. regular expression), and a text to match. The basic usage for these functions is:\n grep(pattern, text)\n grepl(pattern, text)\n regexpr(pattern, text)\n gregexpr(pattern, text)\n regexec(pattern, text)\nEach function has other additional arguments but the important thing to keep in mind are a pattern and some text.\n\n14.1.1 Function grep()\ngrep() is perhaps the most basic functions that allows us to match a pattern in a string vector. The first argument in grep() is a regular expression that specifies the pattern to match. The second argument is a character vector with the text strings on which to search. The output is the indices of the elements of the text vector for which there is a match. If no matches are found, the output is an empty integer vector.\n\n# some text\ntext <- c(\"one word\", \"a sentence\", \"you and me\", \"three two one\")\n\n# pattern\npat <- \"one\"\n\n# default usage\ngrep(pat, text)\n\n[1] 1 4\n\n\nAs you can tell from the output in the previous example, grep() returns a numeric vector. This indicates that the 1st and 4th elements contained a match. In contrast, the 2nd and the 3rd elements did not.\nWe can use the argument value to modify the way in which the output is presented. If we choose value = TRUE, instead of returning the indices, grep() returns the content of the string vector:\n\n# with 'value' (showing matched text)\ngrep(pat, text, value = TRUE)\n\n[1] \"one word\"      \"three two one\"\n\n\nAnother interesting argument to play with is invert. We can use this parameter to obtain unmatches strings by setting its value to TRUE\n\n# with 'invert' (showing unmatched parts)\ngrep(pat, text, invert = TRUE)\n\n[1] 2 3\n\n# same with 'values'\ngrep(pat, text, invert = TRUE, value = TRUE)\n\n[1] \"a sentence\" \"you and me\"\n\n\nIn summary, grep() can be used to subset a character vector to get only the elements containing (or not containing) the matched pattern.\n\n\n14.1.2 Function grepl()\nThe function grepl() enables us to perform a similar task as grep(). The difference resides in that the output are not numeric indices, but logical (TRUE / FALSE). Hence you can think of grepl() as grep-logical. Using the same text string of the previous examples, here’s the behavior of grepl():\n\n# some text\ntext <- c(\"one word\", \"a sentence\", \"you and me\", \"three two one\")\n\n# pattern\npat <- \"one\"\n\n# default usage\ngrepl(pat, text)\n\n[1]  TRUE FALSE FALSE  TRUE\n\n\nNote that we get a logical vector of the same length as the character vector. Those elements that matched the pattern have a value of TRUE; those that didn’t match the pattern have a value of FALSE.\n\n\n14.1.3 Function regexpr()\nTo find exactly where the pattern is found in a given string, we can use the regexpr() function. This function returns more detailed information than grep() providing us:\n\nwhich elements of the text vector actually contain the regex pattern, and\nidentifies the position of the substring that is matched by the regular expression pattern\n\n\n# some text\ntext <- c(\"one word\", \"a sentence\", \"you and me\", \"three two one\")\n\n# default usage\nregexpr(\"one\", text)\n\n[1]  1 -1 -1 11\nattr(,\"match.length\")\n[1]  3 -1 -1  3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n\nAt first glance the output from regexpr() may look a bit messy but it’s very simple to interpret. What we have in the output are three displayed elements. The first element is an integer vector of the same length as text giving the starting positions of the first match. In this example the number 1 indicates that the pattern \"one\" starts at the position 1 of the first element in text. The negative index -1 means that there was no match; the number 11 indicates the position of the substring that was matched in the fourth element of text.\nThe attribute \"match.length\" gives us the length of the match in each element of text. Again, a negative value of -1 means that there was no match in that element. Finally, the attribute \"useBytes\" has a value of TRUE which means that the matching was done byte-by-byte rather than character-by-character.\n\n\n14.1.4 Function gregexpr()\nThe function gregexpr() does practically the same thing as regexpr(): identify where a pattern is within a string vector, by searching each element separately. The only difference is that gregexpr() has an output in the form of a list. In other words, gregexpr() returns a list of the same length as text, each element of which is of the same form as the return value for regexpr(), except that the starting positions of every (disjoint) match are given.\n\n# some text\ntext <- c(\"one word\", \"a sentence\", \"you and me\", \"three two one\")\n\n# pattern\npat <- \"one\"\n\n# default usage\ngregexpr(pat, text)\n\n[[1]]\n[1] 1\nattr(,\"match.length\")\n[1] 3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[2]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[3]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[4]]\n[1] 11\nattr(,\"match.length\")\n[1] 3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n\n\n\n14.1.5 Function regexec()\nThe function regexec() is very close to gregexpr() in the sense that the output is also a list of the same length as text. Each element of the list contains the starting position of the match. A value of -1 reflects that there is no match. In addition, each element of the list has the attribute \"match.length\" giving the lengths of the matches (or -1 for no match):\n\n# some text\ntext <- c(\"one word\", \"a sentence\", \"you and me\", \"three two one\")\n\n# pattern\npat <- \"one\"\n\n# default usage\nregexec(pat, text)\n\n[[1]]\n[1] 1\nattr(,\"match.length\")\n[1] 3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[2]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[3]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[4]]\n[1] 11\nattr(,\"match.length\")\n[1] 3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE"
  },
  {
    "objectID": "14-regex-baser.html#pattern-replacement-functions",
    "href": "14-regex-baser.html#pattern-replacement-functions",
    "title": "14  Regex Functions in R",
    "section": "14.2 Pattern Replacement Functions",
    "text": "14.2 Pattern Replacement Functions\nSometimes finding a pattern in a given string vector is all we want. However, there are occasions in which we might also be interested in replacing one pattern with another one. For this purpose we can use the substitution functions sub() and gsub(). The difference between sub() and gsub() is that the former replaces only the first occurrence of a pattern whereas the latter replaces all occurrences.\nThe replacement functions require three main arguments: a regex pattern to be matched, a replacement for the matched pattern, and the text where matches are sought. The basic usage is:\nsub(pattern, replacement, text)\ngsub(pattern, replacement, text)\n\n14.2.1 Replacing first occurrence with sub()\nThe function sub() replaces the first occurrence of a pattern in a given text. This means that if there is more than one occurrence of the pattern in each element of a string vector, only the first one will be replaced. For example, suppose we have the following text vector containing various strings:\n Rstring = c(\"The R Foundation\", \n             \"for Statistical Computing\", \n             \"R is FREE software\",\n             \"R is a collaborative project\")\nImagine that our aim is to replace the pattern \"R\" with a new pattern \"RR\". If you use sub() this is what we obtain:\n\n# string\nRstring <- c(\"The R Foundation\", \n            \"for Statistical Computing\", \n            \"R is FREE software\",\n            \"R is a collaborative project\")\n\n# substitute 'R' with 'RR'\nsub(\"R\", \"RR\", Rstring)\n\n[1] \"The RR Foundation\"             \"for Statistical Computing\"    \n[3] \"RR is FREE software\"           \"RR is a collaborative project\"\n\n\nAs you can tell, only the first occurrence of the letter R is replaced in each element of the text vector. Note that the word FREE in the third element also contains an R but it was not replaced. This is because it was not the first occurrence of the pattern.\n\n\n14.2.2 Replacing all occurrences with gsub()\nTo replace not only the first pattern occurrence, but all of the occurrences we should use gsub() (think of it as general or global substition). If we take the same vector Rstring and patterns of the last example, this is what we obtain when we apply gsub()\n\n# string\nRstring <- c(\"The R Foundation\", \n            \"for Statistical Computing\", \n            \"R is FREE software\",\n            \"R is a collaborative project\")\n\n# substitute\ngsub(\"R\", \"RR\", Rstring)\n\n[1] \"The RR Foundation\"             \"for Statistical Computing\"    \n[3] \"RR is FRREE software\"          \"RR is a collaborative project\"\n\n\nThe obtained output is almost the same as with sub(), except for the third element in Rstring. Now the occurrence of R in the word FREE is taken into account and gsub() changes it to FRREE."
  },
  {
    "objectID": "14-regex-baser.html#splitting-character-vectors",
    "href": "14-regex-baser.html#splitting-character-vectors",
    "title": "14  Regex Functions in R",
    "section": "14.3 Splitting Character Vectors",
    "text": "14.3 Splitting Character Vectors\nBesides the operations of finding patterns and replacing patterns, another common task is splitting a string based on a pattern. To do this R comes with the function strsplit() which is designed to split the elements of a character vector into substrings according to regex matches.\nIf you check the help documentation—help(strsplit)—you will see that the basic usage of strsplit() requires two main arguments:\n strsplit(x, split)\nx is the character vector and split is the regular expression pattern. However, in order to keep the same notation that we’ve been using with the other grep() functions, it is better if we think of x as text, and split as pattern. In this way we can express the usage of strsplit() as:\n strsplit(text, pattern)\nOne of the typical tasks in which we can use strsplit() is when we want to break a string into individual components (i.e. words). For instance, if we wish to separate each word within a given sentence, we can do that specifying a blank space \" \" as splitting pattern:\n\n# a sentence\nsentence <- c(\"R is a collaborative project with many contributors\")\n\n# split into words\nstrsplit(sentence, \" \")\n\n[[1]]\n[1] \"R\"             \"is\"            \"a\"             \"collaborative\"\n[5] \"project\"       \"with\"          \"many\"          \"contributors\" \n\n\nAnother basic example may consist in breaking apart the portions of a telephone number by splitting those sets of digits joined by a dash \"-\"\n\n# telephone numbers\ntels <- c(\"510-548-2238\", \"707-231-2440\", \"650-752-1300\")\n\n# split each number into its portions\nstrsplit(tels, \"-\")\n\n[[1]]\n[1] \"510\"  \"548\"  \"2238\"\n\n[[2]]\n[1] \"707\"  \"231\"  \"2440\"\n\n[[3]]\n[1] \"650\"  \"752\"  \"1300\""
  },
  {
    "objectID": "15-fun-plot1.html",
    "href": "15-fun-plot1.html",
    "title": "15  Fun Plots (part 1)",
    "section": "",
    "text": "This chapter and the next one are dedicated to create a couple of fun projects in which you get to apply what we have covered so far.\nThe idea is to produce some plots with some text on it. But not any kind of text."
  },
  {
    "objectID": "15-fun-plot1.html#me-you-plot",
    "href": "15-fun-plot1.html#me-you-plot",
    "title": "15  Fun Plots (part 1)",
    "section": "15.1 Me & You Plot",
    "text": "15.1 Me & You Plot\nThe first plot is intended to be a postcard—e.g. for Saint Valentine’s day. After reading this kind of tutorial, you should be able to make youw own plot, print it and give it to your significant other.\nThe idea is to make a chart with your name and the name of your significant other, adding a touch of randomness in the location of the text, the sizes, and the colors.\nFirst we generate the x-y coordinates. We’ll use 100 points, and set the random seed to 333:\n\n# random seed\nset.seed(333)\n\n# x-y coordinates\nn <- 100\nx <- rnorm(n)\ny <- rnorm(n, 1, 2)\n\nThe first step involves producing a very basic-raw plot (nothing fancy). We use plot() for this purpose:\n\nplot(x, y)\n\nThe plot() produces a scatter diagram with a 100 points on it.\nThe following step consists of replacing the dots by some text: your name and the one of your significant other. To hide the dots, we set the parameter type = \"n\", which means that we don’t want anything to be plotted. To show the text, we use the low level plotting function text(). We use the same coordinates, but this time we specify the displayed labels:\n\nplot(x, y, type = \"n\")\ntext(x, y, labels = \"me & you\")\n\nAgain, this is a very preliminary plot; something basic that allows us to start getting a feeling of how the chart looks like.\nThe second step is to change the background color. One way to do this is by specifying the bg graphical parameter inside the par() function:\n\n# graphical parameters\nop <- par(bg = \"gray10\")\n# plot text\nplot(x, y, type = \"n\")\ntext(x, y, \n     labels = \"me & you\",\n     col = \"white\")\n\n\n\n# reset default parameters\npar(op)\n\npar() has default settings. Everytime you call par() and change one of the associated parameters, the subsequent plots will be displayed with those values. To set parameters in a temporary way, you can assign them to an object: i.e. op. After the plot is produced, we reset the default graphical parameters with the instruction par(op).\nWe are getting closer to the desired look of the postcard. The final stage is to add some color to the text, and change their size. The size of the labels will also be random with a uniform distribution.\nR provides several ways to specify colors. In this example we will use the hsv() function (i.e. hue-saturation-value). This function requires three parameters: hue (color), saturation, and value. Hues are specified with a range from 0 to 1. We generate some random numbers in the interval 0.85 - 0.95 to get some hues red, pink, fuchsia colors. hsv() also takes the optional parameters alpha to determined the alpha transparency.\n\n# text size\nsizes <- runif(n, 0.5, 3)\n\n# text color\nhues <- runif(n, 0.85, 0.95)\nalphas <- runif(n, 0.1, 1)\n\n\nop <- par(bg = \"gray10\", mar = rep(0, 4))\nplot(x, y, type = \"n\", axes = FALSE, \n     xlab = '', ylab = '')\ntext(x, y, \n     labels = \"me & you\", \n     font = 3, \n     col = hsv(hues, 1, 1, alphas),\n     cex = sizes)\n\n\n\npar(op)\n\nTo save the image, we call pdf(). To give the image the dimensions of a standard postcard, you can specify width = 5 and height = 3.5, that is, 5 inches wide and 3.5 inches tall (you can choose other dimensions if you want):\n\npdf(file = \"figure/me-and-you3.pdf\", width = 5, height = 3.5)\nop <- par(bg = \"gray10\", \n          mar = rep(0, 4))\nplot(x, y, type = \"n\", axes = FALSE, \n     xlab = '', ylab = '')\ntext(x, y, \n     labels = \"me & you\", \n     font = 3, \n     col = hsv(hues, 1, 1, alphas),\n     cex = sizes)\npar(op)\ndev.off()\n\nIf you save the image in png format, you could also use it as a wallpaper for your computer:\n\n\n\nA wallpaper chart for your significant other"
  },
  {
    "objectID": "16-fun-plot2.html",
    "href": "16-fun-plot2.html",
    "title": "16  Fun Plots (part 2)",
    "section": "",
    "text": "In the preceding chapter we created a first entertaining plot. In this chapter we move on to our second fun graphic involving some strings."
  },
  {
    "objectID": "16-fun-plot2.html#colored-jittery-text",
    "href": "16-fun-plot2.html#colored-jittery-text",
    "title": "16  Fun Plots (part 2)",
    "section": "16.1 Colored Jittery Text",
    "text": "16.1 Colored Jittery Text\nFor our second fun plot, let’s consider some text. For instance, part of the famous speech by Dr. King:\n\nI have a dream that my four little children will one day live in a nation, where they will not be judged by the color of their skin but by the content of their character.\n\nLet’s put the text in a character vector:\n\nspeech <- c(\n  \"I have a dream that my four little children\",\n  \"will one day live in a nation\", \n  \"where they will not be judged by the color of their skin\",\n  \"but by the content of their character.\"\n)\n\nFirst we are going to plot the text as a single string, collapsing it with some new-line characters \"\\n\":\n\nplot(0, 0, type = 'n')\ntext(0, 0, paste(speech, collapse = '\\n'))\n\n\n\n\nNotice that we’re using basic coordinates with a center for the plot on (0,0). This helps us identify reference points both in the x-axis and the y-axis for future manipulation of the character strings.\nIn order to plot each character with a different size and with different coordinates, we need to split the strings into individual characters. To do this we use the almighty function strsplit(). For testing purposes, let’s take one sentence from MLK’s speech. Also, we’ll assign x-axis coordinates by dividing the range of the x-axis (from -1 to 1) in equal parts taking into account the number of characters in the input string:\n\n# one sentence for testing purposes\nstr <- \"I have a dream that my four little children\"\n\n# splitting str in individual characters\ntxt <- unlist(strsplit(str, split = ''))\n\n# x-coordinates for each character\nnchars <- length(txt)\nxs <- seq(-1, 1, length.out = nchars)\n\nplot(0, 0, type = 'n')\nfor (i in 1:nchars) {\n  text(xs[i], 0, labels = txt[i], cex = 1)\n}\n\n\n\n\nNow we can add color and modify the size of the characters. In this case we’ll use the rainbow() palette for colors, and the runif() function to generate uniform values to modify the sizes of the letters:\n\n# character expansion and colors\nrcex <- runif(nchars, 1.5, 2)\ncols <- rainbow(nchars, v = 0.8)\n\nplot(0, 0, type = 'n')\nfor (i in 1:nchars) {\n  text(xs[i], 0, labels = txt[i], cex = rcex, col = cols[i])\n}\n\n\n\n\nFinally, let’s add some jitter to the y-position. We do this by adding some noise following a normal distribution with mean zero and a small standard deviation via the rnorm() function:\n\n# jitter for y-coordinates\nry <- rnorm(nchars, 0, 0.03)\n\nplot(0, 0, type = 'n')\nfor (i in 1:nchars) {\n  text(xs[i], ry[i], labels = txt[i], cex = rcex, col = cols[i])\n}\n\n\n\n\n\n16.1.1 Assembling the plot\nOnce we have all the necessary elements, we can add the rest of the speech lines, remove the axes, and add a little bit of color to the background. Moreover, to manipulate each line of text (i.e. each element in the speech vector) we break them down with sapply(), so we can loop over each line inside the plot:\n\nstrs <- sapply(speech, function(x) strsplit(x, split=''))\nys <- seq(0.75, -0.75, length.out = length(strs))\n\n# random seed\nset.seed(34587)\n\n# plot text\nop <- par(mar = rep(0, 4), bg = 'gray15')\nplot(0, 0, type = 'n', axes = FALSE)\nfor (elem in 1:length(strs)) {\n  s <- unlist(strs[elem])\n  ns <- length(s)\n  xs <- seq(-1, 1, length.out = ns)\n  rcex <- runif(ns, 1.5, 2)\n  cols <- rainbow(ns, v = 0.8)\n  ry <- rnorm(ns, 0, 0.03)\n  \n  for (i in 1:ns) {\n    text(xs[i], ys[elem] + ry[i], labels = s[i], \n         cex = rcex[i], col = cols[i])\n  }\n}\npar(op)"
  },
  {
    "objectID": "17-basic-examples.html",
    "href": "17-basic-examples.html",
    "title": "17  Basic Examples",
    "section": "",
    "text": "This chapter provides more elaborated examples than the simple demos presented so far. The idea is to show you less abstract scenarios and cases where you could apply the functions and concepts covered so far."
  },
  {
    "objectID": "17-basic-examples.html#reversing-a-string",
    "href": "17-basic-examples.html#reversing-a-string",
    "title": "17  Basic Examples",
    "section": "17.1 Reversing A String",
    "text": "17.1 Reversing A String\nOur first example has to do with reversing a character string. More precisely, the objective is to create a function that takes a string and returns it in reversed order. The trick of this exercise depends on what we understand with the term reversing. For some people, reversing may be understood as simply having the set of characters in reverse order. For others, reversing may be understood as having a set of words in reverse order. Can you see the distinction?\nLet’s consider the following two simple strings:\n\n\"atmosphere\"\n\"the big bang theory\"\n\nThe first string is formed by one single word (atmosphere). The second string is formed by a sentence with four words (the big bang theory). If we were to reverse both strings by characters we would get the following results:\n\n\"erehpsomta\"\n\"yroeht gnab gib eht\"\n\nConversely, if we were to reverse the strings by words, we would obtain the following output:\n\n\"atmosphere\"\n\"theory bang big the\"\n\nFor this example we will implement a function for each type of reversing operation."
  },
  {
    "objectID": "17-basic-examples.html#reversing-a-string-by-characters",
    "href": "17-basic-examples.html#reversing-a-string-by-characters",
    "title": "17  Basic Examples",
    "section": "17.2 Reversing a String by Characters",
    "text": "17.2 Reversing a String by Characters\nThe first case for reversing a string is to do it by characters. This implies that we need to split a given string into its different characters, and then we need to concatenate them back together in reverse order. Let’s try to write a first function:\n\n# function that reverses a string by characters\nreverse_chars <- function(string)\n{\n  # split string by characters\n  string_split = strsplit(string, split = \"\")\n  # reverse order\n  rev_order = nchar(string):1\n  # reversed characters\n  reversed_chars = string_split[[1]][rev_order]\n  # collapse reversed characters\n  paste(reversed_chars, collapse = \"\")\n} \n\nLet’s test our reversing function with a character and numeric vectors:\n\n# try 'reverse_chars'\nreverse_chars(\"abcdefg\")\n\n[1] \"gfedcba\"\n\n# try with non-character input\nreverse_chars(12345)\n\nError in strsplit(string, split = \"\"): non-character argument\n\n\nAs you can see, reverse_chars() works fine when the input is in \"character\" mode. However, it complains when the input is \"non-character\". In order to make our function more robust, we can force the input to be converted as character. The resulting code is given as:\n\n# reversing a string by characters\nreverse_chars <- function(string)\n{\n  string_split = strsplit(as.character(string), split = \"\")\n  reversed_split = string_split[[1]][nchar(string):1]\n  paste(reversed_split, collapse = \"\")\n} \n\nNow if we try our modified function, we get the expected results:\n\n# example with one word\nreverse_chars(\"atmosphere\")\n\n[1] \"erehpsomta\"\n\n# example with a several words\nreverse_chars(\"the big bang theory\")\n\n[1] \"yroeht gnab gib eht\"\n\n\nMoreover, it also works with non-character input:\n\n# try 'reverse_chars'\nreverse_chars(\"abcdefg\")\n\n[1] \"gfedcba\"\n\n# try with non-character input\nreverse_chars(12345)\n\n[1] \"54321\"\n\n\nIf we want to use our function with a vector (more than one element), we can combine it with the lapply() function as follows:\n\n# reverse vector (by characters)\nlapply(c(\"the big bang theory\", \"atmosphere\"), reverse_chars)\n\n[[1]]\n[1] \"yroeht gnab gib eht\"\n\n[[2]]\n[1] \"erehpsomta\""
  },
  {
    "objectID": "17-basic-examples.html#reversing-a-string-by-words",
    "href": "17-basic-examples.html#reversing-a-string-by-words",
    "title": "17  Basic Examples",
    "section": "17.3 Reversing a String by Words",
    "text": "17.3 Reversing a String by Words\nThe second type of reversing operation is to reverse a string by words. In this case the procedure involves splitting up a string by words, re-arrange them in reverse order, and paste them back in one sentence. Here’s how we can defined our reverse_words() function:\n\n# function that reverses a string by words\nreverse_words <- function(string)\n{\n  # split string by blank spaces\n  string_split = strsplit(as.character(string), split = \" \")\n  # how many split terms?\n  string_length = length(string_split[[1]])\n  # decide what to do\n  if (string_length == 1) {\n    # one word (do nothing)\n    reversed_string = string_split[[1]]\n  } else {\n    # more than one word (collapse them)\n    reversed_split = string_split[[1]][string_length:1]\n    reversed_string = paste(reversed_split, collapse = \" \")\n  }\n  # output\n  return(reversed_string)\n} \n\nThe first step inside reverse_words() is to split the string according to a blank space pattern \" \". Then we are counting the number of components resulting from the splitting step. Based on this information there are two options. If there is only one word, then there is nothing to do. If we have more than one words, then we need to re-arrenge them in reverse order and collapse them in a single string.\nOnce we have defined our function, we can try it on the two string examples to check that it works as expected:\n\n# examples\nreverse_words(\"atmosphere\")\n\n[1] \"atmosphere\"\n\nreverse_words(\"the big bang theory\")\n\n[1] \"theory bang big the\"\n\n\nSimilarly, to use our function on a vector with more than one element, we should call it within the lapply() function as follows:\n\n# reverse vector (by words)\nlapply(c(\"the big bang theory\", \"atmosphere\"), reverse_words)\n\n[[1]]\n[1] \"theory bang big the\"\n\n[[2]]\n[1] \"atmosphere\""
  },
  {
    "objectID": "17-basic-examples.html#names-of-files",
    "href": "17-basic-examples.html#names-of-files",
    "title": "17  Basic Examples",
    "section": "17.4 Names of Files",
    "text": "17.4 Names of Files\nImagine that you need to generate the names of 10 data .csv files. All the files have the same prefix name but each of them has a different number: file1.csv, file2.csv, … , file10.csv.\nThere are several ways in which you could generate a character vector with these names. One naive option is to manually type those names and form a vector with c()\n\nc('file1.csv', 'file2.csv', 'file3.csv')\n\n[1] \"file1.csv\" \"file2.csv\" \"file3.csv\"\n\n\nBut that’s not very efficient. Just think about the time it would take you to create a vector with 100 files. A better alternative is to use the vectorized nature of paste()\n\npaste('file', 1:10, '.csv', sep = \"\")\n\n [1] \"file1.csv\"  \"file2.csv\"  \"file3.csv\"  \"file4.csv\"  \"file5.csv\" \n [6] \"file6.csv\"  \"file7.csv\"  \"file8.csv\"  \"file9.csv\"  \"file10.csv\"\n\n\nOr similarly with paste0()\n\npaste0('file', 1:10, '.csv')\n\n [1] \"file1.csv\"  \"file2.csv\"  \"file3.csv\"  \"file4.csv\"  \"file5.csv\" \n [6] \"file6.csv\"  \"file7.csv\"  \"file8.csv\"  \"file9.csv\"  \"file10.csv\""
  },
  {
    "objectID": "17-basic-examples.html#valid-color-names",
    "href": "17-basic-examples.html#valid-color-names",
    "title": "17  Basic Examples",
    "section": "17.5 Valid Color Names",
    "text": "17.5 Valid Color Names\nR comes with the function colors() that returns a vector with the names (in English) of 657 colors available in R. How would you write a function is_color() to test if a given name—in English—is a valid R color. If the provided name is a valid R color, is_color() should return TRUE. If the provided name is not a valid R color is_color() should return FALSE.\n\nis_color <- function(x) {\n  x %in% colors()\n}\n\nLets test it:\n\nis_color('yellow')  # TRUE\n\n[1] TRUE\n\nis_color('blu')     # FALSE\n\n[1] FALSE\n\nis_color('turkuiose') # FALSE\n\n[1] FALSE\n\n\nAnother possible way to write is_color() is comparing if any() element of colors() equals the provided name:\n\nis_color2 <- function(x) {\n  any(colors() == x)\n}\n\nTest it:\n\nis_color2('yellow')  # TRUE\n\n[1] TRUE\n\nis_color2('blu')     # FALSE\n\n[1] FALSE\n\nis_color2('turkuiose') # FALSE\n\n[1] FALSE"
  },
  {
    "objectID": "18-matching-html-tags.html",
    "href": "18-matching-html-tags.html",
    "title": "18  Matching HTML Tags",
    "section": "",
    "text": "In this chapter we review and example that deals with some basic handling of HTML tags. The data for this practical application is the webpage for the R mailing lists: http://www.r-project.org/mail.html (see screenshot below)\nIf you visit the previous webpage you will see that there are five general mailing lists devoted to R:\nAdditionally, there are several specific Special Interest Group (SIG) mailing lists. Here’s a screenshot with some of the special groups:"
  },
  {
    "objectID": "18-matching-html-tags.html#attributes-href",
    "href": "18-matching-html-tags.html#attributes-href",
    "title": "18  Matching HTML Tags",
    "section": "18.1 Attributes href",
    "text": "18.1 Attributes href\nAs a simple example, suppose we wanted to get the href attributes of all the SIG links. For instance, the href attribute of the R-SIG-Mac link is:\nhttps://stat.ethz.ch/mailman/listinfo/r-sig-mac\nIn turn the href attribute of the R-sig-DB link is:\nhttps://stat.ethz.ch/mailman/listinfo/r-sig-db\nIf we take a peek at the html source-code of the webpage, we’ll see that all the links can be found on lines like this one (in just one line of code):\n\"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-mac\\\">\n<code>R-SIG-Mac</code></a>: R Special Interest Group on Mac ports of R</p></li>\"\n\n18.1.1 Getting SIG links\nThe first step is to create a vector of character strings that will contain the lines of the mailing lists webpage. We can create this vector by simply passing the URL name to readLines():\n\n\n\n\n# read html content\nmail_lists = readLines(\"http://www.r-project.org/mail.html\")\n\nIn case you are having problem downloading the HTML file, you can also find a copy in the github repository for data sets of this book. You can use the code below to download a copy of the file to your working directory:\n\n# download file\ngithub <- \"https://raw.githubusercontent.com/gastonstat/strings-data\"\ntextfile <- \"/main/data/mail.html\"\ndownload.file(url = paste0(github, textfile), destfile = \"mail.html\")\n\nOnce you have the data in your working directory, you can import in R with readLines()\n\nmail_lists <- readLines(\"mail.html\")\n\nThe first elements in mail_lists are:\n\nhead(mail_lists)\n\n[1] \"<!DOCTYPE html>\"                                                             \n[2] \"<html lang=\\\"en\\\">\"                                                          \n[3] \"  <head>\"                                                                    \n[4] \"    <meta charset=\\\"utf-8\\\">\"                                                \n[5] \"    <meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=edge\\\">\"               \n[6] \"    <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\"\n\n\nOnce we’ve read the HTML content of the R mailing lists webpage, the next step is to define our regex pattern that matches the SIG links.\n'^.*<p><a href=\"(https.*)\">.*$'\nLet’s examine the proposed pattern. By using the caret ^ and dollar sign $ we can describe our pattern as an entire line. Next to the caret we match anything zero or more times followed by a <td> tag. Then there is a blank space matched zero or more times, followed by an anchor tag with its href attribute. Note that we are using double quotation marks to match the href attribute (\"(https.*)\"). Moreover, the entire regex pattern is surrounded by single quotations marks ' '. Here is how we can get the SIG links:\n\n# SIG's href pattern\nsig_pattern = '^.*<p><a href=\"(https.*)\">.*$'\n\n# find SIG href attributes\nsig_hrefs = grep(sig_pattern, mail_lists, value = TRUE)\n\n# let's see first 5 elements\nhead(sig_hrefs, n = 5)\n\n[1] \"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-mac\\\"><code>R-SIG-Mac</code></a>: R Special Interest Group on Mac ports of R</p></li>\"                                     \n[2] \"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-db\\\"><code>R-SIG-DB</code></a>: R SIG on Database Interfaces</p></li>\"                                                     \n[3] \"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-debian\\\"><code>R-SIG-Debian</code></a>: R Special Interest Group for Debian ports of R</p></li>\"                           \n[4] \"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-dynamic-models\\\"><code>R-SIG-dynamic-models</code></a>: Special Interest Group for Dynamic Simulation Models in R</p></li>\"\n[5] \"<li><p><a href=\\\"https://stat.ethz.ch/mailman/listinfo/r-sig-ecology\\\"><code>R-SIG-ecology</code></a>: Using R in ecological data analysis</p></li>\"                                    \n\n\nWe need to get rid of the extra html tags. We can easily extract the names of the note files using the sub() function (since there is only one link per line, we don’t need to use gsub(), although we could).\n\n# get first matched group\nsigs = sub(sig_pattern, '\\\\1', sig_hrefs)\nsigs\n\n [1] \"https://stat.ethz.ch/mailman/listinfo/r-sig-mac\"           \n [2] \"https://stat.ethz.ch/mailman/listinfo/r-sig-db\"            \n [3] \"https://stat.ethz.ch/mailman/listinfo/r-sig-debian\"        \n [4] \"https://stat.ethz.ch/mailman/listinfo/r-sig-dynamic-models\"\n [5] \"https://stat.ethz.ch/mailman/listinfo/r-sig-ecology\"       \n [6] \"https://stat.ethz.ch/mailman/listinfo/r-sig-epi\"           \n [7] \"https://stat.ethz.ch/mailman/listinfo/r-sig-fedora\"        \n [8] \"https://stat.ethz.ch/mailman/listinfo/r-sig-finance\"       \n [9] \"https://stat.ethz.ch/mailman/listinfo/r-sig-geo\"           \n[10] \"https://stat.ethz.ch/mailman/listinfo/r-sig-gr\"            \n[11] \"https://stat.ethz.ch/mailman/listinfo/r-sig-gui\"           \n[12] \"https://stat.ethz.ch/mailman/listinfo/r-sig-hpc\"           \n[13] \"https://stat.ethz.ch/mailman/listinfo/r-sig-insurance\"     \n[14] \"https://stat.ethz.ch/mailman/listinfo/r-sig-jobs\"          \n[15] \"https://stat.ethz.ch/mailman/listinfo/r-sig-mediawiki\"     \n[16] \"https://stat.ethz.ch/mailman/listinfo/r-sig-meta-analysis\" \n[17] \"https://stat.ethz.ch/mailman/listinfo/r-sig-mixed-models\"  \n[18] \"https://stat.ethz.ch/mailman/listinfo/r-sig-networks\"      \n[19] \"https://stat.ethz.ch/mailman/listinfo/r-sig-phylo\"         \n[20] \"https://stat.ethz.ch/mailman/listinfo/r-sig-qa\"            \n[21] \"https://stat.ethz.ch/mailman/listinfo/r-sig-robust\"        \n[22] \"https://stat.ethz.ch/mailman/listinfo/r-sig-teaching\"      \n\n\nAs you can see, we are using the regex pattern \\\\1 in the sub() function. Generally speaking \\\\N is replaced with the N-th group specified in the regular expression. The first matched group is referenced by \\\\1. In our example, the first group is everything that is contained in the curved brackets, that is: (https.*), which are in fact the links we are looking for."
  },
  {
    "objectID": "19-data-cleaning.html",
    "href": "19-data-cleaning.html",
    "title": "19  Data Cleaning",
    "section": "",
    "text": "In this application we are going to work with the Men’s Long Jump World Record Progression data from wikipedia (see screenshot below).\nhttps://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression#Low_altitude_record_progression_1965%E2%80%931991"
  },
  {
    "objectID": "19-data-cleaning.html#import-data",
    "href": "19-data-cleaning.html#import-data",
    "title": "19  Data Cleaning",
    "section": "19.1 Import Data",
    "text": "19.1 Import Data\nTo import the data of the Record Progression table you can use a couple of functions from the package rvest.\n\nlibrary(rvest)\n\nwiki_jump <- 'https://en.wikipedia.org/wiki/Men%27s_long_jump_world_record_progression'\n\nlong_jump <- read_html(wiki_jump)\ntbl <- html_table(html_node(long_jump, 'table'))\n\nThe function read_html() reads the html file of the wikipedia page. This will produce an object of type \"xml_document\" which we can further manipulate with other functions in \"rvest\".\nBecause the Record progression data is in an html table node, you can use html_node() to locate such table in the XML document. And then extract it with html_table().\n\nstr(tbl, vec.len = 1)\n\ntibble [18 × 5] (S3: tbl_df/tbl/data.frame)\n $ Mark   : chr [1:18] \"7.61 m (24 ft 11 1⁄2 in)\" ...\n $ Wind   : num [1:18] NA NA ...\n $ Athlete: chr [1:18] \"Peter O'Connor (IRE)\" ...\n $ Venue  : chr [1:18] \"Dublin, Ireland\" ...\n $ Date   : chr [1:18] \"5 August 1901[1]\" ...\n\n\nAs you can tell, the extracted table tbl is a data frame with 18 rows and 5 columns."
  },
  {
    "objectID": "19-data-cleaning.html#extracting-meters",
    "href": "19-data-cleaning.html#extracting-meters",
    "title": "19  Data Cleaning",
    "section": "19.2 Extracting Meters",
    "text": "19.2 Extracting Meters\nThe first task consists of looking at the values in column Mark, and find how to retrieve the distance values expressed in meters. For example, the first element in Mark is:\n\ntbl$Mark[1]\n\n[1] \"7.61 m (24 ft 11 1⁄2 in)\"\n\n\nThe goal is to obtain the number 7.61. One way to achieve this task is via the substr() function.\n\nsubstr(tbl$Mark[1], start = 1, stop = 4)\n\n[1] \"7.61\"\n\n\nWe can do that for the entire vector:\n\nmeters <- substr(tbl$Mark, start = 1, stop = 4)\nmeters\n\n [1] \"7.61\" \"7.69\" \"7.76\" \"7.89\" \"7.90\" \"7.93\" \"7.98\" \"8.13\" \"8.21\" \"8.24\"\n[11] \"8.28\" \"8.31\" \"8.31\" \"8.34\" \"8.35\" \"8.35\" \"8.90\" \"8.95\"\n\n\nNotice that the meter values are not really numeric but character. In order to have meters as numbers, we should coerce them with as.numeric()\n\nmeters <- as.numeric(substr(tbl$Mark, start = 1, stop = 4))\nmeters\n\n [1] 7.61 7.69 7.76 7.89 7.90 7.93 7.98 8.13 8.21 8.24 8.28 8.31 8.31 8.34 8.35\n[16] 8.35 8.90 8.95\n\n\n\nExtracting Meters with Regular Expressions\nInstead of using the function substr() to obtain the distance values, let’s see how to achieve the same task using regular expressions. To do this we must determine a pattern to be matched. So, what is the pattern that all the distance values (in meters) have in common?\n\nmark1 <- tbl$Mark[1]\nmark1\n\n[1] \"7.61 m (24 ft 11 1⁄2 in)\"\n\n\nIf you look at the Mark content, you will notice that the target pattern is formed by: a digit, followed by a dot, followed by two digits. Such pattern can be codified as: \"[0-9]\\\\.[0-9][0-9]\". So let’s test it and see if there’s match:\n\nstr_detect(mark1, pattern = \"[0-9]\\\\.[0-9][0-9]\")\n\n[1] TRUE\n\n\nTo extract the distance pattern we use str_extract()\n\nstr_extract(mark1, pattern = \"[0-9]\\\\.[0-9][0-9]\")\n\n[1] \"7.61\"\n\n\nAnd then we can apply it on the entire column to get:\n\nstr_extract(tbl$Mark, pattern = \"[0-9]\\\\.[0-9][0-9]\")\n\n [1] \"7.61\" \"7.69\" \"7.76\" \"7.89\" \"7.90\" \"7.93\" \"7.98\" \"8.13\" \"8.21\" \"8.24\"\n[11] \"8.28\" \"8.31\" \"8.31\" \"8.34\" \"8.35\" \"8.35\" \"8.90\" \"8.95\""
  },
  {
    "objectID": "19-data-cleaning.html#extracting-country",
    "href": "19-data-cleaning.html#extracting-country",
    "title": "19  Data Cleaning",
    "section": "19.3 Extracting Country",
    "text": "19.3 Extracting Country\nConsider the column Athlete. The first value corresponds to Petter O'Connor from Ireland.\n\ntbl$Athlete[1]\n\n[1] \"Peter O'Connor (IRE)\"\n\n\nLet’s create a vector peter for this athlete:\n\npeter <- tbl$Athlete[1]\n\nHow can we get the country abbreviation?\n\nsubstr(peter, nchar(peter)-4, nchar(peter))\n\n[1] \"(IRE)\"\n\n\nThat works but it is preferable to exclude the parentheses, that is, the third to last character, as well as the last character:\n\nsubstr(peter, nchar(peter)-3, nchar(peter)-1)\n\n[1] \"IRE\"\n\n\nNow we can apply the substr() command with all the athletes:\n\n# extract country\nsubstr(tbl$Athlete, nchar(tbl$Athlete)-4, nchar(tbl$Athlete))\n\n [1] \"(IRE)\" \"(USA)\" \"(USA)\" \"(USA)\" \"(USA)\" \"(HAI)\" \"(JPN)\" \"(USA)\" \"(USA)\"\n[10] \"(USA)\" \"(USA)\" \"(URS)\" \"(USA)\" \"(USA)\" \"(USA)\" \"(URS)\" \"(USA)\" \"(USA)\"\n\ncountry <- substr(tbl$Athlete, nchar(tbl$Athlete)-3, nchar(tbl$Athlete)-1)\ncountry\n\n [1] \"IRE\" \"USA\" \"USA\" \"USA\" \"USA\" \"HAI\" \"JPN\" \"USA\" \"USA\" \"USA\" \"USA\" \"URS\"\n[13] \"USA\" \"USA\" \"USA\" \"URS\" \"USA\" \"USA\""
  },
  {
    "objectID": "19-data-cleaning.html#cleaning-dates",
    "href": "19-data-cleaning.html#cleaning-dates",
    "title": "19  Data Cleaning",
    "section": "19.4 Cleaning Dates",
    "text": "19.4 Cleaning Dates\nNow let’s consider tha values in column Date:\n\n# first 5 dates\ntbl$Date[1:5]\n\n[1] \"5 August 1901[1]\" \"23 July 1921[1]\"  \"7 July 1924[1]\"   \"13 June 1925[1]\" \n[5] \"7 July 1928[1]\"  \n\n\nNotice that all the date values are formed by the day-number, the name of the month, the year, and then the characters [1]. Obviously we don’t need those last three characters [1].\n\ndate1 <- tbl$Date[1]\ndate1\n\n[1] \"5 August 1901[1]\"\n\n\nFirst let’s see how to match the pattern [1]. Perhaps the first option that an inexperience user would try is:\n\nstr_detect(date1, pattern = \"[1]\")\n\n[1] TRUE\n\n\nAccording to str_detect(), there’s is a match, so let’s see what exactly \"[1]\" is matching:\n\nstr_match(date1, pattern = \"[1]\")\n\n     [,1]\n[1,] \"1\" \n\n\nMmmm, not quite right. We are matching the character \"1\" but not \"[1]\". Why? Because brackets are metacharacters. So in order to match brackets as brackets we need to escape them:\n\nstr_match(date1, pattern = \"\\\\[1\\\\]\")\n\n     [,1] \n[1,] \"[1]\"\n\n\nNow we are talking. The next step involves using str_replace() to match the pattern \"\\\\[1\\\\]\" and replace it with an empty string \"\":\n\nstr_replace(date1, pattern = \"\\\\[1\\\\]\", replacement = \"\")\n\n[1] \"5 August 1901\"\n\n\nThen, we can get an entire vector of clean dates:\n\n# clean dates\ndates <- str_replace(tbl$Date, pattern = \"\\\\[1\\\\]\", replacement = \"\")\ndates\n\n [1] \"5 August 1901\"     \"23 July 1921\"      \"7 July 1924\"      \n [4] \"13 June 1925\"      \"7 July 1928\"       \"9 September 1928\" \n [7] \"27 October 1931\"   \"25 May 1935\"       \"12 August 1960\"   \n[10] \"27 May 1961\"       \"16 July 1961\"      \"10 June 1962\"     \n[13] \"15 August 1964\"    \"12 September 1964\" \"29 May 1965\"      \n[16] \"19 October 1967\"   \"18 October 1968\"   \"30 August 1991\""
  },
  {
    "objectID": "19-data-cleaning.html#month-and-day",
    "href": "19-data-cleaning.html#month-and-day",
    "title": "19  Data Cleaning",
    "section": "19.5 Month and Day",
    "text": "19.5 Month and Day\nWe can further manipulate the dates. For example, say we are interested in extracting the name of the month. In the first date, this corresponds to extracting \"August\":\n\ndates[1]\n\n[1] \"5 August 1901\"\n\n\nHow can we do that? Several approaches can be applied in this case. For example, let’s inspect the format of the month names:\n\ndates[1:5]\n\n[1] \"5 August 1901\" \"23 July 1921\"  \"7 July 1924\"   \"13 June 1925\" \n[5] \"7 July 1928\"  \n\n\nThey all begin with an upper case letter, followed by the rest of the characters in lower case. If we want to match month names formed by four letters (e.g. June, July), we could look for the pattern \"[A-Z][a-z][a-z][a-z]\"\n\nstr_extract(dates, pattern = \"[A-Z][a-z][a-z][a-z]\")\n\n [1] \"Augu\" \"July\" \"July\" \"June\" \"July\" \"Sept\" \"Octo\" NA     \"Augu\" NA    \n[11] \"July\" \"June\" \"Augu\" \"Sept\" NA     \"Octo\" \"Octo\" \"Augu\"\n\n\nThe previous pattern \"[A-Z][a-z][a-z][a-z]\" not only matches \"June\" and \"July\" but also \"Augu\", \"Sept\", \"Octo\". In addition, we have some missing values.\nBecause the month names have variable lengths, we can use a repetition or quantifier operator. More specifically, we could look for the pattern \"[A-Z][a-z]+\", that is: an upper case letter, followed by a lower case letter, repeated one or more times. The plus + tells the regex engine to attempt to match the preceding token once or more:\n\nmonth_names <- str_extract(dates, pattern = \"[A-Z][a-z]+\")\nmonth_names\n\n [1] \"August\"    \"July\"      \"July\"      \"June\"      \"July\"      \"September\"\n [7] \"October\"   \"May\"       \"August\"    \"May\"       \"July\"      \"June\"     \n[13] \"August\"    \"September\" \"May\"       \"October\"   \"October\"   \"August\"   \n\n\nHaving extracted the name of the months, we can take advantage of a similar pattern to extract the days. How? Using a pattern formed by one digit range and the plus sign: \"[0-9]+\"\n\nstr_extract(dates, pattern = \"[0-9]+\")\n\n [1] \"5\"  \"23\" \"7\"  \"13\" \"7\"  \"9\"  \"27\" \"25\" \"12\" \"27\" \"16\" \"10\" \"15\" \"12\" \"29\"\n[16] \"19\" \"18\" \"30\""
  },
  {
    "objectID": "19-data-cleaning.html#extracting-year",
    "href": "19-data-cleaning.html#extracting-year",
    "title": "19  Data Cleaning",
    "section": "19.6 Extracting Year",
    "text": "19.6 Extracting Year\nWhat about extracting the year number?\n\ndates[1]\n\n[1] \"5 August 1901\"\n\n\nOne option that we have discussed already is to use substr() or str_sub()\n\nstr_sub(dates, start = nchar(dates)-3, end = nchar(dates))\n\n [1] \"1901\" \"1921\" \"1924\" \"1925\" \"1928\" \"1928\" \"1931\" \"1935\" \"1960\" \"1961\"\n[11] \"1961\" \"1962\" \"1964\" \"1964\" \"1965\" \"1967\" \"1968\" \"1991\"\n\n\nor simply indicate a negative starting position (to counting from the end of the string):\n\nstr_sub(dates, start = -4)\n\n [1] \"1901\" \"1921\" \"1924\" \"1925\" \"1928\" \"1928\" \"1931\" \"1935\" \"1960\" \"1961\"\n[11] \"1961\" \"1962\" \"1964\" \"1964\" \"1965\" \"1967\" \"1968\" \"1991\"\n\n\nAnother option consists in using a pattern formed by four digits: \"[0-9][0-9][0-9][0-9]\":\n\nstr_extract(dates[1], pattern = \"[0-9][0-9][0-9][0-9]\")\n\n[1] \"1901\"\n\n\nAn additional option consists in using an end of string anchor with the metacharacter \"$\" (dollar sign), and combine with a repetition operator \"+\" like: \"[0-9]+$\":\n\nstr_extract(dates[1], pattern = \"[0-9]+$\")\n\n[1] \"1901\"\n\n\nWhat is this pattern doing? The part of the pattern \"[0-9]+\" indicates that we want to match one or more digits. In order to tell the engine to match the pattern at the end of the string, we must use the anchor \"$\".\nThe same task can be achieved with a digit character class \\\\d and the repetition operator +:\n\nstr_extract(dates[1], pattern = \"\\\\d+$\")\n\n[1] \"1901\""
  },
  {
    "objectID": "19-data-cleaning.html#athlete-names",
    "href": "19-data-cleaning.html#athlete-names",
    "title": "19  Data Cleaning",
    "section": "19.7 Athlete Names",
    "text": "19.7 Athlete Names\nNow let’s try to extract the athletes’ first and last names. We could specify a regex pattern for the first name [A-Z][a-z][A-Z]?[a-z]+, followed by a space, followed by an uper case letter, and one or more lower case letters [A-Z][a-z]+:\n\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z][a-z]+\")\n\n [1] NA               \"Edward Gourdin\" \"Robert Le\"      \"DeHart Hubbard\"\n [5] \"Edward Hamm\"    \"Sylvio Cator\"   \"Chuhei Nambu\"   \"Jesse Owens\"   \n [9] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[13] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[17] \"Bob Beamon\"     \"Mike Powell\"   \n\n\nWhat about the first athlete Peter O’Connor? The previous pattern does not include the apostrophe.\n\n# works for Peter O'Connor only\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]'[A-Z][a-z]+\")\n\n [1] \"Peter O'Connor\" NA               NA               NA              \n [5] NA               NA               NA               NA              \n [9] NA               NA               NA               NA              \n[13] NA               NA               NA               NA              \n[17] NA               NA              \n\n\nWhat about this other pattern?\n\n# still only works for Peter O'Connor\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]'[A-Z]?[a-z]+\")\n\n [1] \"Peter O'Connor\" NA               NA               NA              \n [5] NA               NA               NA               NA              \n [9] NA               NA               NA               NA              \n[13] NA               NA               NA               NA              \n[17] NA               NA              \n\n\nRecall that the quantifier (or repetition) operators have an effect on the preceding token. So, the pattern \"[A-Z]'[A-Z]?[a-z]+\" means: an upper case letter, followed by an apostrophe, followed by an optional upper case, followed by one or more lower case letters. In other words, the quantifier \"?\" only has an effect on the second upper case letter.\nIn reality, we want both the apostrophe and the second upper case letters to be optional, so we need to add quantifiers \"?\" to both of them:\n\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]'?[A-Z]?[a-z]+\")\n\n [1] \"Peter O'Connor\" \"Edward Gourdin\" \"Robert Le\"      \"DeHart Hubbard\"\n [5] \"Edward Hamm\"    \"Sylvio Cator\"   \"Chuhei Nambu\"   \"Jesse Owens\"   \n [9] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[13] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[17] \"Bob Beamon\"     \"Mike Powell\"   \n\n\nIf you want to treat a set of characters as a single unit, you must wrap them inside parentheses:\n\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]('[A-Z])?[a-z]+\")\n\n [1] \"Peter O'Connor\" \"Edward Gourdin\" \"Robert Le\"      \"DeHart Hubbard\"\n [5] \"Edward Hamm\"    \"Sylvio Cator\"   \"Chuhei Nambu\"   \"Jesse Owens\"   \n [9] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[13] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter\"      \n[17] \"Bob Beamon\"     \"Mike Powell\"   \n\n\nWe still have an issue with athlete Igor Ter-Ovanesyan. The patterns used so far are only matching the the characters in his last name before the hyphen. We can start by adding a escaped hyphen inside the character set \"[a-z\\\\-]\" at the end of the pattern:\n\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]('[A-Z])?[a-z\\\\-]+\")\n\n [1] \"Peter O'Connor\" \"Edward Gourdin\" \"Robert Le\"      \"DeHart Hubbard\"\n [5] \"Edward Hamm\"    \"Sylvio Cator\"   \"Chuhei Nambu\"   \"Jesse Owens\"   \n [9] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter-\"     \n[13] \"Ralph Boston\"   \"Ralph Boston\"   \"Ralph Boston\"   \"Igor Ter-\"     \n[17] \"Bob Beamon\"     \"Mike Powell\"   \n\n\nNotice that this pattern does match the hyphen but fails to match the second part of the last name (the one after the hyphen). This is because our token is only matching lower case letters. So we also need to include upper case letters in the character set: \"[a-zA-Z\\\\-]\"\n\nstr_extract(tbl$Athlete, pattern = \"[A-Z][a-z][A-Z]?[a-z]+ [A-Z]('[A-Z])?[a-zA-Z\\\\-]+\")\n\n [1] \"Peter O'Connor\"     \"Edward Gourdin\"     \"Robert LeGendre\"   \n [4] \"DeHart Hubbard\"     \"Edward Hamm\"        \"Sylvio Cator\"      \n [7] \"Chuhei Nambu\"       \"Jesse Owens\"        \"Ralph Boston\"      \n[10] \"Ralph Boston\"       \"Ralph Boston\"       \"Igor Ter-Ovanesyan\"\n[13] \"Ralph Boston\"       \"Ralph Boston\"       \"Ralph Boston\"      \n[16] \"Igor Ter-Ovanesyan\" \"Bob Beamon\"         \"Mike Powell\"       \n\n\nThe regex patterns that involve a set such as \"[a-zA-Z]\" can be simplified with a repeated word character class \"\\\\w+\" (recall that \"\\\\w+\" is equivalent to \"[0-9A-Za-z_]\"). We can try to use two repeated word classes:\n\nstr_extract(tbl$Athlete, pattern = \"\\\\w+ \\\\w+\")\n\n [1] \"Peter O\"         \"Edward Gourdin\"  \"Robert LeGendre\" \"DeHart Hubbard\" \n [5] \"Edward Hamm\"     \"Sylvio Cator\"    \"Chuhei Nambu\"    \"Jesse Owens\"    \n [9] \"Ralph Boston\"    \"Ralph Boston\"    \"Ralph Boston\"    \"Igor Ter\"       \n[13] \"Ralph Boston\"    \"Ralph Boston\"    \"Ralph Boston\"    \"Igor Ter\"       \n[17] \"Bob Beamon\"      \"Mike Powell\"    \n\n\nAs you know, we also need to include an apostrphe and the hyphen. In this case, we can include them inside parentheses and separating them with the OR operator \"|\":\n\nstr_extract(tbl$Athlete, pattern = \"\\\\w+ (\\\\w|-|')+\")\n\n [1] \"Peter O'Connor\"     \"Edward Gourdin\"     \"Robert LeGendre\"   \n [4] \"DeHart Hubbard\"     \"Edward Hamm\"        \"Sylvio Cator\"      \n [7] \"Chuhei Nambu\"       \"Jesse Owens\"        \"Ralph Boston\"      \n[10] \"Ralph Boston\"       \"Ralph Boston\"       \"Igor Ter-Ovanesyan\"\n[13] \"Ralph Boston\"       \"Ralph Boston\"       \"Ralph Boston\"      \n[16] \"Igor Ter-Ovanesyan\" \"Bob Beamon\"         \"Mike Powell\""
  },
  {
    "objectID": "20-log-file.html",
    "href": "20-log-file.html",
    "title": "20  Data Log File",
    "section": "",
    "text": "In this example, we’ll be using the text file logfile.txt located in the data/ folder of the book’s github repository:\nhttps://raw.githubusercontent.com/gastonstat/strings-data/main/data/logfile.txt\nThis file is a server log file that contains the recorded events taking place in a web server. The content of the file is in a special format known as common log format.\nhttps://en.wikipedia.org/wiki/Common_Log_Format\nAccording to wikipedia:\nHere’s an example of a log record; the text should be in one line of code, but I’ve split it into 2 lines for readibility purposes:\nIf you want to download a copy of the text file to your working directory (from within R) run the following code:"
  },
  {
    "objectID": "20-log-file.html#reading-the-text-file",
    "href": "20-log-file.html#reading-the-text-file",
    "title": "20  Data Log File",
    "section": "20.1 Reading the text file",
    "text": "20.1 Reading the text file\nThe first step involves reading the data in R. How can you do this? One option is with the readLines() function which reads any text file into a character vector:\n\n# one option is to read in the content with 'readLines()'\nlogs <- readLines('logfile.txt')\n\nLet’s take a peek at the content of the vector logs by running head(logs). We display the output of the first three lines below::\n\n# take a peek at the contents in logs\nhead(logs)\n\n[1] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:01:51:25 -0700] \\\"GET /accesswatch/accesswatch-1.33/ HTTP/1.0\\\" 200 1004\"              \n[2] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:01:51:26 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 304 -\"  \n[3] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:01:51:26 -0700] \\\"GET /sa.inside.jpg HTTP/1.0\\\" 304 -\"                                 \n[4] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:02:20:19 -0700] \\\"GET /accesswatch/accesswatch-1.33/ HTTP/1.0\\\" 200 7791\"              \n[5] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:02:20:20 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 304 -\"  \n[6] \"pd9049dac.dip.t-dialin.net - - [01/May/2001:02:20:20 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/blueblock.gif HTTP/1.0\\\" 304 -\"\n\n\nBecause the file contains 26033 lines (or elements), let’s get a subset by taking a random sample of size 50:\n\n# subset a sample of lines\nset.seed(98765)\ns <- sample(1:length(logs), size = 50)\nsublogs <- logs[s]\n\n\n20.1.1 JPG File Requests\nTo begin our regex experiments, let’s try to find out “how many requests involved a JPG file?”. One way to answer the previous question is by counting the number of lines containing the pattern \"jpg\". We can use grep() to match or detect this pattern:\n\n# matching \"jpg\" (which lements)\ngrep(\"jpg\", sublogs)\n\n [1]  2  6  8 10 11 14 26 34 35 36 40 41 45\n\n# showing value of matches\ngrep(\"jpg\", sublogs, value = TRUE)\n\n [1] \"hj.a11.betware.com - - [29/May/2001:02:15:26 -0700] \\\"GET /testing/images/archi_servlet.jpg HTTP/1.1\\\" 200 18646\"                     \n [2] \"port194.ds1-gl.adsl.cybercity.dk - - [29/May/2001:15:33:04 -0700] \\\"GET /testing/images/archi_jsp.jpg HTTP/1.1\\\" 200 21211\"           \n [3] \"pd9049e9b.dip.t-dialin.net - - [06/May/2001:12:45:35 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 304 -\"     \n [4] \"pd9049e94.dip.t-dialin.net - - [04/May/2001:04:12:53 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 200 108154\"\n [5] \"edslink9.eds.com - - [23/May/2001:02:22:12 -0700] \\\"GET /testing/images/pshtk.jpg HTTP/1.0\\\" 200 34301\"                               \n [6] \"bloodymary.vebis.de - - [22/May/2001:01:15:28 -0700] \\\"GET /testing/images/scope.jpg HTTP/1.0\\\" 200 32117\"                            \n [7] \"line210-137.iplan.com.ar - - [28/May/2001:14:49:26 -0700] \\\"GET /testing/images/archi_servlet.jpg HTTP/1.1\\\" 304 -\"                   \n [8] \"aannecy-101-2-1-40.abo.wanadoo.fr - - [31/May/2001:08:43:33 -0700] \\\"GET /testing/images/pshtk.jpg HTTP/1.1\\\" 200 34301\"              \n [9] \"rr-2s01.inf.fh-rhein-sieg.de - - [23/May/2001:06:40:00 -0700] \\\"GET /xp-r/img17.jpg HTTP/1.0\\\" 304 -\"                                 \n[10] \"pd9541d23.dip.t-dialin.net - - [29/May/2001:07:08:26 -0700] \\\"GET /sa.inside.jpg HTTP/1.1\\\" 304 -\"                                    \n[11] \"rose.ap.dregis.com - - [29/May/2001:05:09:28 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.0\\\" 200 18531\"                             \n[12] \"208.36.196.8 - - [23/May/2001:22:39:40 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.1\\\" 200 18531\"                                   \n[13] \"hlch0enk.htc.com - - [22/May/2001:11:01:53 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.0\\\" 200 18531\"                               \n\n\nWe can try to be more specific by defining a pattern \".jpg\" in which the . corresponds to the literal dot character. To match the dot, we need to escape it with \"\\\\.\":\n\n# we could try to be more precise and match \".jpg\"\ngrep(\"\\\\.jpg \", sublogs, value = TRUE)\n\n [1] \"hj.a11.betware.com - - [29/May/2001:02:15:26 -0700] \\\"GET /testing/images/archi_servlet.jpg HTTP/1.1\\\" 200 18646\"                     \n [2] \"port194.ds1-gl.adsl.cybercity.dk - - [29/May/2001:15:33:04 -0700] \\\"GET /testing/images/archi_jsp.jpg HTTP/1.1\\\" 200 21211\"           \n [3] \"pd9049e9b.dip.t-dialin.net - - [06/May/2001:12:45:35 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 304 -\"     \n [4] \"pd9049e94.dip.t-dialin.net - - [04/May/2001:04:12:53 -0700] \\\"GET /accesswatch/accesswatch-1.33/img/allifou.jpg HTTP/1.0\\\" 200 108154\"\n [5] \"edslink9.eds.com - - [23/May/2001:02:22:12 -0700] \\\"GET /testing/images/pshtk.jpg HTTP/1.0\\\" 200 34301\"                               \n [6] \"bloodymary.vebis.de - - [22/May/2001:01:15:28 -0700] \\\"GET /testing/images/scope.jpg HTTP/1.0\\\" 200 32117\"                            \n [7] \"line210-137.iplan.com.ar - - [28/May/2001:14:49:26 -0700] \\\"GET /testing/images/archi_servlet.jpg HTTP/1.1\\\" 304 -\"                   \n [8] \"aannecy-101-2-1-40.abo.wanadoo.fr - - [31/May/2001:08:43:33 -0700] \\\"GET /testing/images/pshtk.jpg HTTP/1.1\\\" 200 34301\"              \n [9] \"rr-2s01.inf.fh-rhein-sieg.de - - [23/May/2001:06:40:00 -0700] \\\"GET /xp-r/img17.jpg HTTP/1.0\\\" 304 -\"                                 \n[10] \"pd9541d23.dip.t-dialin.net - - [29/May/2001:07:08:26 -0700] \\\"GET /sa.inside.jpg HTTP/1.1\\\" 304 -\"                                    \n[11] \"rose.ap.dregis.com - - [29/May/2001:05:09:28 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.0\\\" 200 18531\"                             \n[12] \"208.36.196.8 - - [23/May/2001:22:39:40 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.1\\\" 200 18531\"                                   \n[13] \"hlch0enk.htc.com - - [22/May/2001:11:01:53 -0700] \\\"GET /testing/images/archi.jpg HTTP/1.0\\\" 200 18531\"                               \n\n\nA similar output of grep() can be obtained with str_detect(), which allows you to detect what elements contain a match to the specified pattern:\n\n# matching \"jpg\" (which lements)\nstr_detect(string = sublogs, pattern = \"\\\\.jpg\")\n\n [1] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE\n[13] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[37] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[49] FALSE FALSE\n\n\nWe can do the same for PNG extensions (or for GIF or ICO):\n\n# matching \"png\" (which lements)\nstr_detect(string = sublogs, pattern = \"\\\\.png\")\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[49] FALSE  TRUE\n\n\n\n\n20.1.2 Extracting file extensions\nAnother common task when working with regular expressions has to do with pattern extraction. For this purposes, we can use str_extract():\n\n# extracting \"jpg\" (which lements)\nstr_extract(string = sublogs, pattern = \"\\\\.jpg\")\n\n [1] NA     \".jpg\" NA     NA     NA     \".jpg\" NA     \".jpg\" NA     \".jpg\"\n[11] \".jpg\" NA     NA     \".jpg\" NA     NA     NA     NA     NA     NA    \n[21] NA     NA     NA     NA     NA     \".jpg\" NA     NA     NA     NA    \n[31] NA     NA     NA     \".jpg\" \".jpg\" \".jpg\" NA     NA     NA     \".jpg\"\n[41] \".jpg\" NA     NA     NA     \".jpg\" NA     NA     NA     NA     NA    \n\n\nstr_extract() actually let us confirm that we are matching the desired patterns. Notice that when there is no match, str_extract() returns a missing value NA.\n\n\n20.1.3 Image files\nNow let’s try to detect all types of image files: JPG, PNG, GIF, ICO\n\n# looking for image file extensions\njpgs <- str_detect(logs, pattern = \"\\\\.jpg \")\nsum(jpgs)\n\n[1] 5509\n\npngs <- str_detect(logs, pattern = \"\\\\.png \")\nsum(pngs)\n\n[1] 1374\n\ngifs <- str_detect(logs, pattern = \"\\\\.gif\")\nsum(gifs)\n\n[1] 8818\n\nicos <- str_detect(logs, pattern = \"\\\\.ico \")\nsum(icos)\n\n[1] 100\n\n\n\n\n20.1.4 How to match image files with one regex pattern?\nWe can use character sets to define a more generic pattern. For instance, to match \"jpg\" or \"png\", we could join three character sets: \"[jp][pn][g]\". The first set [jp] looks for j or p, the second set [pn] looks for p or n, and the third set simply looks for g.\n\n# matching \"jpg\" or \"png\"\njpg_png_lines <- str_detect(sublogs, \"[jp][pn][g]\")\nsum(jpg_png_lines)\n\n[1] 15\n\n\nIncluding the dot, we can use: \"\\\\.[jp][pn][g]\"\n\n# matching \"jpg\" or \"png\"\njpg_png_lines <- str_detect(sublogs, \"\\\\.[jp][pn][g]\")\nsum(jpg_png_lines)\n\n[1] 15\n\n\nWe could generalize the pattern to include the GIF and ICO extensions:\n\n# matching \"jpg\" or \"png\" or \"gif\"\nimage_lines1 <- str_detect(sublogs, \"[jpgi][pnic][gfo]\")\nsum(image_lines1)\n\n[1] 44\n\n\nTo confirm that we are actually matching jpg, png, gif and ico, let’s use str_extract()\n\n# are we correctly extracting image file extensions?\nstr_extract(sublogs, \"[jpgi][pnic][gfo]\")\n\n [1] \"ing\" \"ing\" NA    \"ing\" \"ing\" \"ing\" \"ing\" \"jpg\" \"ing\" \"jpg\" \"ing\" \"ing\"\n[13] NA    \"ing\" \"ing\" \"ing\" \"ing\" \"ing\" \"ing\" \"gif\" \"ing\" \"ico\" \"ing\" \"ing\"\n[25] \"ing\" \"ing\" \"ing\" NA    \"pco\" \"ing\" \"gif\" \"ing\" NA    \"ing\" \"inf\" \"jpg\"\n[37] \"gif\" \"ing\" \"ing\" \"ing\" \"ing\" \"gif\" \"ing\" \"ing\" \"ing\" \"ing\" NA    NA   \n[49] \"gif\" \"ing\"\n\n\nThe previous pattern does not really work as expected: note that we are matching the patterns formed by \"ing\" and \"inf\" which do not correspond to image file extensions.\nAn alternative way to detect JPG and PNG is by grouping patterns inside parentheses, and separating them with the metacharacter \"|\" which means OR:\n\n# detecting .jpg OR .png\njpg_png <- str_detect(sublogs, \"\\\\.jpg|\\\\.png\")\nsum(jpg_png)\n\n[1] 15\n\n\nHere’s how to detect all the extension in one single pattern:\n\n# matching \"jpg\" or \"png\" or \"gif\" or \"ico\"\nimage_lines <- str_detect(sublogs, \"\\\\.jpg|\\\\.png|\\\\.gif|\\\\.ico\")\nsum(image_lines)\n\n[1] 28\n\n\nTo make sure our regex operation is successful, let’s see the output of str_extract():\n\nimages_output <- str_extract(sublogs, \"\\\\.jpg|\\\\.png|\\\\.gif|\\\\.ico\")\nimages_output\n\n [1] NA     \".jpg\" NA     NA     NA     \".jpg\" \".gif\" \".jpg\" NA     \".jpg\"\n[11] \".jpg\" NA     NA     \".jpg\" NA     \".png\" NA     NA     NA     \".gif\"\n[21] \".gif\" \".gif\" NA     NA     \".gif\" \".jpg\" NA     NA     \".gif\" NA    \n[31] \".gif\" \".gif\" NA     \".jpg\" \".jpg\" \".jpg\" \".gif\" NA     NA     \".jpg\"\n[41] \".jpg\" \".gif\" NA     \".gif\" \".jpg\" \".gif\" NA     NA     \".gif\" \".png\"\n\n\nThere’s some repetition with the dot character; we can modify our previous pattern by placing the dot \"\\\\.\" at the beginning:\n\nimages_output <- str_extract(sublogs, \"\\\\.jpg|png|gif|ico\")\nimages_output\n\n [1] NA     \".jpg\" NA     NA     NA     \".jpg\" \"gif\"  \".jpg\" NA     \".jpg\"\n[11] \".jpg\" NA     NA     \".jpg\" NA     \"png\"  NA     NA     NA     \"gif\" \n[21] \"gif\"  \"ico\"  NA     NA     \"gif\"  \".jpg\" NA     NA     \"gif\"  NA    \n[31] \"gif\"  \"gif\"  NA     \".jpg\" \".jpg\" \".jpg\" \"gif\"  NA     NA     \".jpg\"\n[41] \".jpg\" \"gif\"  NA     \"gif\"  \".jpg\" \"gif\"  NA     NA     \"gif\"  \"png\" \n\n\nNotice that the dot only appears next to \".jpg\" but not with the other type of extensions. What we need to do is group the file extensions by surrounding them with parentheses:\n\nimages_output <- str_extract(sublogs, \"\\\\.(jpg|png|gif|ico)\")\nimages_output\n\n [1] NA     \".jpg\" NA     NA     NA     \".jpg\" \".gif\" \".jpg\" NA     \".jpg\"\n[11] \".jpg\" NA     NA     \".jpg\" NA     \".png\" NA     NA     NA     \".gif\"\n[21] \".gif\" \".gif\" NA     NA     \".gif\" \".jpg\" NA     NA     \".gif\" NA    \n[31] \".gif\" \".gif\" NA     \".jpg\" \".jpg\" \".jpg\" \".gif\" NA     NA     \".jpg\"\n[41] \".jpg\" \".gif\" NA     \".gif\" \".jpg\" \".gif\" NA     NA     \".gif\" \".png\"\n\n\nNow let’s apply the pattern on the entire log file, to count the number of files of each type:\n\n# frequencies\nimg_extensions <- str_extract(logs, \"\\\\.(jpg|png|gif|ico)\")\ntable(img_extensions)\n\nimg_extensions\n.gif .ico .jpg .png \n8818  100 5509 1374"
  }
]